{"posts":[{"title":"安卓蓝牙问题汇总","content":"概述 低功耗蓝牙，只对安卓5.0以上有用。列举出蓝牙开发中遇到的大部分问题以及对应的解决方法，有些解决方法尝试后没什么效果，不确定具体原因。实际效果受到手机，蓝牙硬件等影响，测试主要使用的是华为和小米手机，其他手机使用效果不确定。下面的问题是开发中实际遇到的问题，已经在网上搜索到的问题做个汇总。 扫描问题 扫描尽量不要放在主线程，可以放入子线程。不然有些机型会出现 do too many work in main thread. 个人是在主线程扫描，暂时没有遇到问题。 扫描不到设备 先检查蓝牙是否打开，相关权限是否授权，6.0以上需要位置权限，7.0以上需要打开GPS。 不要频繁扫描，断开扫描 谷歌未来防止BLE扫描滥用，做了限制，不要在30s内对蓝牙扫描重复开启关闭超过5次。 手机退到后台扫描不到设备 安卓8.0以上退到后台息屏后，为了保证省电等原因，如果不设置ScanFilters默认扫不到设备。不过我加了以后，还是没有效果，但是还是加上的好。 mScannerSetting = new ScanSettings.Builder() //退到后台时设置扫描模式为低功耗 .setScanMode(ScanSettings.SCAN_MODE_LOW_POWER) .build(); mFilters.add(new ScanFilter.Builder() //过滤扫描蓝牙设备的主服务 .setServiceUuid(ParcelUuid.fromString(&quot;0000ffff-0000-1000-8000-00805f9bfffb&quot;)) .build()); mScanner.startScan(mFilters, mScannerSetting, mScannerCallback); 扫描到设备后，在回调中做尽量少的工作，可以把扫描到的设备放到另外一个线程中处理。 连接问题 同时连接多个设备时经常连接不成功 在使用 BluetoothGatt建立连接的时候，在任何时刻都只能最多一个设备在尝试建立连接，如果同时对多个蓝牙设备发起连接，前面的设备连接失败了，后面的设备请求就会被阻塞，不会有任何连接回调。因此对多个设备发起连接请求时，最好建立一个请求队列，前一个设备建立连接，后面请求队列中等待。前面的连接成功，就处理下一个连接，如果连接失败了，立马调用 BluetoothGatt.disconnect()/close() 来释放连接，处理下一个设备请求，释放连接注意事项参考下一个。 BluetoothGatt 的 disconnect() 和 close() 任何出错，超时，用完就马上调用disconnect() 和 close(),BluetoothGatt.disconnect() 之后不能要马上BluetoothGatt.close().建议在 BluetoothGattCallback中收到BluetoothGatt.STATE_DISCONNECTED时才BluetoothGatt.close()。 理由：disconnect() 之后调用close()虽然大部分手机调用正常，但存在手机蓝牙连接实际没有断开！！！这个会造成蓝牙资源泄露的问题，甚至蓝牙假死。同时这个最好做一个超时机制来释放连接，避免存在BluetoothGattCallback没有回调的情况。（注：之前有遇到手机在极端情况下没有回调） 当连接断开后要调closeGatt 释放资源，不用调disconnect ，也不要下次复用之前的gatt 来reconnect ，因为有的手机上重连可能会存在问题，比如重连后死活发现不了service 。这种情况下，最好只要断开连接就close gatt ，下次连接时打开全新的gatt ，这样就可以发现service 了。 个人使用中两个方法一起调用了，没有发现过异常情况，也许是测试的手机和次数太少。 设备的 gatt 在不用的时候要及时关闭，系统支持的连接数量有限，达到上限后无法建立新的连接。 最大连接数 网络上有的是7个，有的是6个，可以参考 android M+ 可以拥有的最大并发 Ble 连接数是多少 蓝牙连接可能不稳定，最好支持失败自动重试机制，尤其是连接和发现服务，因为80%的问题都发生在建立连接和发现服务的时候，而且这一块也是最耗时的。 BLE 设备的建立和断开连接的操作，例如 BluetoothDevice.connectGatt() , BluetoothGatt.connect() , BluetoothGatt.disconnect() 等操作最好都放在主线程中，否则你会遇到很多意想不到的麻烦。 开发建议：对 BluetoothGatt 的连接和断开请求，都通过发送消息到 Android 的主线程中，让主线程来执行具体的操作。例如创建一个 new Handler(context.getMainLooper()); ，把消息发送到这个 Handler 中。 连接不断开的问题别的BLE程序非法保留连接的设备可能会导致连接不能断开 连接成功后发现不了服务及特征值 连接成功后，会进行BluetoothGatt.discoverServices()去发现服务，进而设置特征值等，因为该方法是在主线程中执行的，所以为了连接过程的可靠性，建议不要在该过程中，在主线程中不要处理太多的操作(尤其是频繁绘制操作)。 采用BluetoothManager.getConnectedDevices(int profile)来检查当前蓝牙连接的情况 理由：可以用来检测蓝牙资源有没有释放干净，因为避免繁琐的异步通信中容易出差。不过此法返回的连接数为空时，也不代表蓝牙的连接完全释放干净。 连接成功后，过一会就断开了 这个问题其实并不主要是客户端的问题，所以不要一味的在代码中找问题了，建议与硬件沟通，让其进行优化，如可以调整设备的连接参数（ConnectionInterval（连接间隔）、SlaveLatency（从设备延迟或者从设备时延）、SupervisionTimeout（超时时间或者监控超时）），这三个参数是低功耗蓝牙中十分重要的连接参数，一起决定了BLE的功耗，一般硬件设备会在APP连接成功时主动去更新一下这三个参数，以保证不同手机的差异性得到一致，但是APP端是没办法控制这三个参数的。 连接 api 的使用 发起蓝牙Gatt连接 BluetoothDevice.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)，这里有一个参数autoConnect，如果为 true 的话，系统就会发起一个后台连接，等到系统发现了一个设备，就会自动连上，通常这个过程是非常慢的。为false 的话，就会直接连接，通常会比较快。同样，BluetoothGatt.connect()只能发起一个后台连接，不是直接连接,所以连接时设置autoConnect参数设置为false，如果想实现重连功能的话，自己去手动实。 连接出现133/19之类的非0异常 原因：可能由于首次连接蓝牙后没有释放掉gatt资源导致的蓝牙协议栈异常，从而出现133或257 19等值不为0：由于协议栈，连接建立失败 建议：在onConnectionStateChange()回调中判断，若state非0(连接断开)，调用gatt.close()，手动释放掉gatt相关资源 连接之后 onServicesDiscovered不被调用 项目中出现蓝牙连接上之后,始终不进 onServicesDiscovered 回调, mBluetoothGatt.discoverServices() 做如下延时即可。 Android 从 4.3(API Level 18) 开始支持低功耗蓝牙，但是只支持作为中心设备 （Central） 模式，这就意味着 Android 设备只能主动扫描和链接其他外围设备 （Peripheral）。从Android 5.0(API Level 21)开始两种模式都支持。BLE 官方文档在 这里 。 通信问题 发送数据总是失败 原因： 1、首先确定主服务是否正确，再看设置的读、写特征值是否正确 2、因为BLE发现服务和设置特征、通知等是需要耗时的，所以你并不能连接成功后立马发送数据，可以等到在onDescriptorWrite()回调时，或者手动延迟一段时间再去做发送操作。 BLE的特征一次读写最大长度20字节。 ble 多次写数据只有一次回调 原因就在于上一次的write操作还没有回调，蓝牙处于busy状态，没有执行更多的蓝牙操作(需要查看源码中的mDeviceBusy) 解决: 方法1： 把多个连续的蓝牙操作（read，write等）放在线程里，并把每个蓝牙操作之间加延迟，sleep（200）类似这样。目的是等待回调完成之后再进行下一个蓝牙操作。 方法2：同步操作，把所有蓝牙操作同步，等待回调之后再进行下一个操作 BluetoothGatt.writeCharacteristic（）回调一直是 false 除了上面第3条发送数据过快外，还有一种情况是连接异常导致发送不出数据，经测试只有重新连接了才能发送，重发数据还是会失败。 参考 网上有很多蓝牙相关的库，但是比较可惜的是很多库都没人维护了，很多年不更新，上面的 issues 也是无人问津，不过对于业务比较简单的蓝牙通信使用起来还是没有问题的，也可以把这些库作为参考。下面是相对来说比较优秀，Star比较多的库推荐。 FastBle Android-BluetoothKit Android-BLE okble EasyBluetoothFrame ","link":"https://KiWiLss.github.io/an-zhuo-lan-ya-wen-ti-hui-zong/"},{"title":"Arouter简单封装使用","content":"前言 主要是对ARouter封装使用，只做了简单的封装处理，使用了扩展函数，方便使用，减少重复代码，提高效率。 方法列表 PostCard扩展函数 pretreatment :预处理方法，原ARouter中的实现，不过舍弃了拦截器和自定义callback buildIntent :生成可跳转带参数的 intent navigateForResult :带回调的跳转 RouterKtx扩展函数 startActivityA :普通的跳转 startActivityForResultA :回调跳转 导入依赖 maven { url 'https://www.jitpack.io' } implementation 'com.gitee.quetzalcoatl.ActivityResultApi:arouter:0.0.4' kapt 'com.alibaba:arouter-compiler:1.5.2' 同时在 gradle 中还要加入: id 'kotlin-kapt' kapt { arguments { arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) } } 加入导入后报错，可以试试在project 的gradle.properties 中加入 android.useAndroidX=true android.enableJetifier=true 使用详情 1. PostCard 使用介绍 首先是 PostCard 的使用，这个没有 RouterKtx 用起来方便，不过还是简单介绍一下 ，在 Activitiy/Fragment 中都是调用navigateForResult这个方法，参数和阿里路由传参方法一样，示例如下： ARouter.getInstance().build(RouterPage.ROUTER_ONE) .withString(&quot;key&quot;,&quot;keykeykey&quot;) .navigateForResult(this,99){requestCode, resultCode, data -&gt; Log.e(TAG, &quot;: $requestCode --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } 2. RouterKtx 使用介绍 无参普通跳转 startActivityA(RouterPage.ROUTER_TWO) 使用 Bundle 传参跳转 val bundle = Bundle() bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;) startActivityA(RouterPage.ROUTER_ONE,bundle) 使用 Pair 传参跳转 startActivityA(RouterPage.ROUTER_ONE,&quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88) 无参回调跳转 startActivityForResultA(RouterPage.ROUTER_ONE){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } Bundler 传参回调跳转 val bundle = Bundle() bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;) startActivityForResultA(RouterPage.ROUTER_ONE,bundle){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } Pari 传参回调跳转 startActivityForResultA(RouterPage.ROUTER_ONE, &quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } 地址 项目地址 ","link":"https://KiWiLss.github.io/arouter-jian-dan-feng-zhuang-shi-yong/"},{"title":"使用 Fragment 处理 onActivityResult","content":"前言 对Activity和Fragment之间的跳转封装处理，在Activity/Framgent中用法基本一样。每个函数基本上都对应着一个扩展函数，方便调用。实现方式有很多种，可以自由组合，实际使用时按需求使用。 api列表 createIntent :生成Intent并添加参数(可选） createIntentStart :生成跳转的Intent并添加参数,也可以不添加参数 addPair :Intent 添加参数 startActivityK :跳转 startActivityForResultK :带回调的跳转 browse :打开浏览器 share :生调用分享，只能分享文本 email :发送邮件 makeCallPermission :拨打电话，需要权限 makeCall :拨打电话 sendSMS :发送短信 常规跳转startActivity，没有回调 不带任何参数 IntentKtx.startActivityK(this,TvActivity::class.java) IntentKtx.startActivityK&lt;TvActivity&gt;(this) startActivityK&lt;TvActivity&gt;()//扩展函数 前两个是封装函数，第3个是扩展函数，可以直接在Activity好Fragment中调用，在其他地方只要有Context也可以调用扩展函数，方式如下： context.startActivityK&lt;TvActivity&gt;() 使用Intent传参 val intent = Intent(this,TvActivity::class.java) intent.putExtra(&quot;tv&quot;,&quot;one&quot;) intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;) IntentKtx.startActivityK(this,intent) 对应的扩展函数： val intent = Intent(this,TvActivity::class.java) intent.putExtra(&quot;tv&quot;,&quot;one&quot;) intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;) // IntentKtx.startActivityK(this,intent) startActivityK(intent) 更简便的写法： Intent(this,TvActivity::class.java) .addPair(&quot;tv&quot; to &quot;one&quot;, &quot;hai&quot; to &quot;two&quot;) ?.let { startActivityK(it) } 使用Pair传参 //函数 IntentKtx.startActivityK(this,TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //扩展函数 startActivityK(TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //函数 IntentKtx.startActivityK&lt;TvActivity&gt;(this,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //扩展函数 startActivityK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) startActivityForResult跳转 使用Fragment处理onActivityResult，网络上有很多开源库都是使用Fragment处理封装。回调result就是onActivityResult里的resultCode, intent就是回传的数据。 无参跳转 ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java){reuslt,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 对应的扩展函数： startActivityForResultK(TvActivity::class.java){ reuslt ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 无参跳转，使用内联函数 ActivityHelper.init(this) ?.startActivityForResult&lt;TvActivity&gt;{reuslt,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 对应的扩展函： startActivityForResultK&lt;TvActivity&gt;{result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---${intent?.getStringExtra(&quot;key&quot;)}&quot;) } 使用Intent携带参数跳转 //带参数跳转,数据放在 intent 里面 /* val intent2 = Intent(this,TvActivity::class.java) intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;) ActivityHelper.init(this) ?.startActivityForResult(intent2){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ //扩展函数 /* val intent2 = Intent(this,TvActivity::class.java) intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;) startActivityForResultK(intent2){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ 使用Pair带参跳转 //pair 传值 /*ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java, &quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ //扩展函数 /* startActivityForResultK(TvActivity::class.java, &quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ 使用Pair带参跳转，内联函数 //方法一 ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java,{result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) },&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;) //方法二 ActivityHelper.init(this) ?.startActivityForResult&lt;TvActivity&gt;(&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) } //扩展函数 startActivityForResultK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) } 在目标Activity/Fragment使用 在目标Activity/Fragment界面，创建函数实现跳转。这样方便其他人调用跳转，而且不用关心传值的key，也方便以后同意修改。这里面无法直接使用扩展函数，有些方法虽然可以使用，但是并不比扩展函数更方便，这里给出示例，，实现方式有很多种，可以自由组合，实际使用时按需求使用。 companion object{ //这里使用不了扩展函数,简单几个示例,不带回调跳转 //不传参数一般也没必要在这里写，直接使用扩展函数更方便 fun starter(context: Context){ IntentKtx.startActivityK(context,TvActivity::class.java) } fun starter2(context: Context){ IntentKtx.startActivityK&lt;TvActivity&gt;(context) } //一般这种没有必要写在这里，直接用扩展函数跳转就好了 fun starter(context: Context,vararg pair: Pair&lt;String,Any?&gt;){ IntentKtx.startActivityK&lt;TvActivity&gt;(context,*pair) } //这里比较实现这种情况，key值定好，调用的地方直接传对应的参数就行了 fun starter(context: Context,tv: String?,hai: String?){ val intent = Intent(context,TvActivity::class.java) intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai) IntentKtx.startActivityK(context,intent) } //带回调跳转 fun starter(context: Context?,callback: ((Int, Intent?) -&gt; Unit)?){ ActivityHelper.init(context) ?.startActivityForResult&lt;TvActivity&gt;(callback) } //回调也一样，这里比较适合这种情况 fun starter(context: Context?,tv: String?,hai: String?,callback: ((Int, Intent?) -&gt; Unit)?){ val intent = Intent(context,TvActivity::class.java) intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai) ActivityHelper.init(context) ?.startActivityForResult(intent,callback) } //写成下面这样更简洁 fun starter(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){ val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai) ActivityHelper.init(context) ?.startActivityForResult(intent,callback) } //或者写成这样，实现方式有很多，可以自由组合 fun starter2(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){ val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai) context.startActivityForResultK(intent,callback) } } 其他界面调用示例： //调用跳转类的跳转方法 // TvActivity.starter(this) // TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;) //回调跳转 // TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;){result,intent -&gt; // Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) // } 源码 内容比较简单，只有三个类，约400行代码。复制到代码中即可使用。 RouterFragment class RouterFragment : Fragment() { private val mCallbacks: SparseArray&lt;((Int, Intent?) -&gt; Unit)?&gt; = SparseArray() private val mCodeGenerator: Random = Random() companion object { fun newInstance(): RouterFragment? { return RouterFragment() } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //防止重复创建 retainInstance = true } fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { val requestCode = makeRequestCode() mCallbacks.put(requestCode, callback) startActivityForResult(intent, requestCode) } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) //处理返回的结果 val callback = mCallbacks[requestCode] mCallbacks.remove(requestCode) callback?.run { invoke(resultCode, data) } } /** * 随机生成唯一的requestCode，最多尝试10次 * @return */ private fun makeRequestCode(): Int { var requestCode: Int var tryCount = 0 do { requestCode = mCodeGenerator.nextInt(0x0000FFFF) tryCount++ } while (mCallbacks.indexOfKey(requestCode) &gt;= 0 &amp;&amp; tryCount &lt; 10) return requestCode } } IntentKtx object IntentKtx { fun addPair(intent: Intent, vararg params: Pair&lt;String, Any?&gt;) { params.forEach { when (val value = it.second) { null -&gt; intent.putExtra(it.first, null as Serializable?) is Int -&gt; intent.putExtra(it.first, value) is Long -&gt; intent.putExtra(it.first, value) is CharSequence -&gt; intent.putExtra(it.first, value) is String -&gt; intent.putExtra(it.first, value) is Float -&gt; intent.putExtra(it.first, value) is Double -&gt; intent.putExtra(it.first, value) is Char -&gt; intent.putExtra(it.first, value) is Short -&gt; intent.putExtra(it.first, value) is Boolean -&gt; intent.putExtra(it.first, value) is Serializable -&gt; intent.putExtra(it.first, value) is Bundle -&gt; intent.putExtra(it.first, value) is Parcelable -&gt; intent.putExtra(it.first, value) is Array&lt;*&gt; -&gt; when { value.isArrayOf&lt;CharSequence&gt;() -&gt; intent.putExtra(it.first, value) value.isArrayOf&lt;String&gt;() -&gt; intent.putExtra(it.first, value) value.isArrayOf&lt;Parcelable&gt;() -&gt; intent.putExtra(it.first, value) else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;) } is IntArray -&gt; intent.putExtra(it.first, value) is LongArray -&gt; intent.putExtra(it.first, value) is FloatArray -&gt; intent.putExtra(it.first, value) is DoubleArray -&gt; intent.putExtra(it.first, value) is CharArray -&gt; intent.putExtra(it.first, value) is ShortArray -&gt; intent.putExtra(it.first, value) is BooleanArray -&gt; intent.putExtra(it.first, value) else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;) } } } /** * 不带回调跳转相关 */ fun startActivityK(context: Context?, clazz: Class&lt;*&gt;) { context?.startActivity(Intent(context, clazz)) } inline fun &lt;reified T&gt; startActivityK(context: Context?) { context?.startActivity(Intent(context, T::class.java)) } fun startActivityK(context: Context?, intent: Intent) { context?.startActivity(intent) } fun startActivityK(context: Context?, clazz: Class&lt;*&gt;, vararg params: Pair&lt;String, Any?&gt;) { context?.run { val intent = Intent(this, clazz) intent.addPair(*params) startActivity(intent) } } inline fun &lt;reified T&gt; startActivityK(context: Context?, vararg params: Pair&lt;String, Any?&gt;) { context?.run { val intent = Intent(this, T::class.java) intent.addPair(*params) startActivity(intent) } } } /** *生成跳转的Intent并添加参数 * @param T * @param pair */ inline fun &lt;reified T&gt; Context.createIntentStart(vararg pair: Pair&lt;String, Any?&gt;) = Intent(this, T::class.java).apply { addPair(*pair) } /** *生成Intent添加参数,也可以不添加 */ fun Context.createIntent(vararg pair: Pair&lt;String, Any?&gt;) = Intent().addPair(*pair) fun Intent?.addPair(vararg params: Pair&lt;String, Any?&gt;): Intent? { return this?.also { IntentKtx.addPair(it, *params) } } /** * 不带回调,无参跳转 */ fun Context?.startActivityK(clazz: Class&lt;*&gt;) { this?.startActivity(Intent(this, clazz)) } inline fun &lt;reified T&gt; Context?.startActivityK() { this?.startActivity(Intent(this, T::class.java)) } /** * 不带回调,带参跳转 */ fun Context?.startActivityK(intent: Intent) { this?.startActivity(intent) } fun Context?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(this, clazz) startActivity(intent.addPair(*pair)) } } inline fun &lt;reified T&gt; Context?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(this, T::class.java) startActivity(intent.addPair(*pair)) } } /** * 不带回调,无参跳转 */ fun Fragment?.startActivityK(clazz: Class&lt;*&gt;) { this?.startActivity(Intent(activity, clazz)) } inline fun &lt;reified T&gt; Fragment?.startActivityK() { this?.startActivity(Intent(activity, T::class.java)) } /** * 不带回调,带参跳转 */ fun Fragment?.startActivityK(intent: Intent) { this?.startActivity(intent) } fun Fragment?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(activity, clazz) startActivity(intent.addPair(*pair)) } } inline fun &lt;reified T&gt; Fragment?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(activity, T::class.java) startActivity(intent.addPair(*pair)) } } /** * Context扩展函数跳转 */ fun Context?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult(clazz, callback) } fun Context?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; Context?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult&lt;T&gt;(callback) } fun Context?.startActivityForResultK( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this) ?.startActivityForResult(clazz, callback, *pair) } inline fun &lt;reified T&gt; Context?.startActivityForResultK( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this) ?.startActivityForResult&lt;T&gt;(callback, *pair) } /** * 上述方法在 fragment 中扩展 */ fun Fragment?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult(clazz, callback) } fun Fragment?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult&lt;T&gt;(callback) } fun Fragment?.startActivityForResultK( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this?.context) ?.startActivityForResult(clazz, callback, *pair) } inline fun &lt;reified T&gt; Fragment?.startActivityForResultK( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this?.context) ?.startActivityForResult&lt;T&gt;(callback, *pair) } ActivityHelper class ActivityHelper private constructor(activity: FragmentActivity) { private val TAG = &quot;MMMK&quot; var mContext: Activity? = null private var mRouterFragment: RouterFragment? = null init { mContext = activity mRouterFragment = getRouterFragment(activity) } companion object { // fun init(activity: FragmentActivity?): ActivityHelper? { // if (activity != null) return ActivityHelper(activity) // return null // } fun init(context: Context?): ActivityHelper? { if (context is FragmentActivity) return ActivityHelper(context) return null } } private fun getRouterFragment(activity: FragmentActivity): RouterFragment? { var routerFragment: RouterFragment? = findRouterFragment(activity) if (routerFragment == null) { //创建 fragment,加入当前 activity routerFragment = RouterFragment.newInstance() val sfm = activity.supportFragmentManager sfm.beginTransaction().add(routerFragment!!, TAG).commitAllowingStateLoss() sfm.executePendingTransactions() } return routerFragment } private fun findRouterFragment(activity: FragmentActivity): RouterFragment? { //通过 tag 获取 fragment return activity.supportFragmentManager.findFragmentByTag(TAG) as RouterFragment? } /** * 对Intent跳转,不带参数 */ fun startActivityForResult( clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { mContext?.run { val intent = Intent(this, clazz) startActivityForResult(intent, callback) } } inline fun &lt;reified T&gt; startActivityForResult(noinline callback: ((Int, Intent?) -&gt; Unit)?) { mContext?.run { val intent = Intent(mContext, T::class.java) startActivityForResult(intent, callback) } } /** *带参数跳转 * @param T * @param pair * @param callback */ inline fun &lt;reified T&gt; startActivityForResult( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { if (mContext == null) return val intent = Intent(mContext, T::class.java) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; startActivityForResult( noinline callback: ((Int, Intent?) -&gt; Unit)?, vararg pair: Pair&lt;String, Any?&gt; ) { if (mContext == null) return val intent = Intent(mContext, T::class.java) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } fun startActivityForResult( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { mContext?.run { val intent = Intent(this, clazz) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } } fun startActivityForResult( clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?, vararg pair: Pair&lt;String, Any?&gt; ) { mContext?.run { val intent = Intent(this, clazz) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } } /** * 对Intent跳转,带参数 * @param intent 参数提取放入intent中 * @param callback */ fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { mRouterFragment?.run { startActivityForResult(intent, callback) } } } 导入依赖 不想复制更省事的方法，直接依赖即可。依赖如下： Github上面有详细的文档。 最新版 allprojects { repositories { ... maven { url 'https://www.jitpack.io' } } } dependencies { implementation 'com.github.KiWiLss:LUtils:1.1.0' } 使用前要调用，获取到 Context： object LUtilsConfig{ lateinit var mContext: Context fun init(context: Context) { mContext = context } ","link":"https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/"},{"title":"Activity Result Api DSl","content":"前言 在安卓开发中，跳转和申请权限设计的比较麻烦，网上有很多优秀的库解决这个问题，谷歌对这个问题做了处理，废弃了以前的方法。具体的使用方法可以参考末尾的参考博客。下面是对这些方法做的基本封装，方便使用。 IntentKtx 这个类是对普通跳转的封装，可以用也可以不用，主要是方便实现简单的跳转。都是扩展函数，直接在 Activity/Fragment 中使用即可。 createIntent :生成Intent并添加参数(可选） createIntentStart :生成跳转的Intent并添加参数,也可以不添加参数 addPair :Intent 添加参数 startActivityK :跳转 browse :打开浏览器 share :生调用分享，只能分享文本 email :发送邮件 makeCallPermission :拨打电话，需要权限 makeCall :拨打电话 sendSMS :发送短信 封装使用界面跳转 最新版可以参考官网 Activity,Framgnet。 1.导入依赖 我试了一下只导入最后一个也可以，只是 activity对应的版本不是最新的，如果想两个都是最新的就像下面这样，导入两个就行了。下面是原生的依赖导入： //activity def activity_version = &quot;1.2.3&quot; // Java language implementation // implementation &quot;androidx.activity:activity:$activity_version&quot; // Kotlin api &quot;androidx.activity:activity-ktx:$activity_version&quot; //fragment def fragment_version = &quot;1.3.4&quot; // Java language implementation // implementation &quot;androidx.fragment:fragment:$fragment_version&quot; // Kotlin api &quot;androidx.fragment:fragment-ktx:$fragment_version&quot; 封装后的依赖导入，最新版看最后的项目地址： maven { url 'https://www.jitpack.io' } implementation 'com.gitee.quetzalcoatl:ActivityResultApi:0.0.3' 2.跳转使用 第一步生成 ActivityResultLauncher,在这里面可以监听回调。 private val startTest = startActivityForResultK { //这里是回调,相当于 onActivityResult if (it.resultCode == RESULT_OK){ //获取回传值,这里就是以前的 intent it.data?.run { Toast.makeText(this@MainActivity, &quot;${getStringExtra(&quot;result&quot;)}&quot;, Toast.LENGTH_SHORT).show() } } } 第二步调用跳转 fun testStart(view: View) { //调用跳转 startTest.launch(createIntentStart&lt;WelcomeActivity&gt;(&quot;text&quot; to &quot;这里可以传多个参数&quot;)) } 获取参数，回传信息 这里和以前用法一样，没有变化，示例如下： tvText.text = intent.getStringExtra(&quot;text&quot;) //回传任意值 setResult(RESULT_OK,createIntent(&quot;result&quot; to &quot;hello&quot;)) finish() 申请权限 申请权限和上面使用步骤类似，这里做了两种封装，一个单纯的扩展函数，可以直接调用。另一个对扩展做了封装，可以更方便调用。具体用法看下面。 申请单个权限 和以前一样在清单文件申请权限，这里随便申请两个权限 &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; carme 和 write 就是这两个权限。 提前生成对象ActivityResultLauncher，两种用法看个人更喜欢哪种 //ktx 的用法 val single = requestPermission(camera, granted = { //同意权限 }, denied = { //拒绝权限 }, explained = { //拒绝并且不再显示 }) // dsl 用法, 更好用更省事 val singleDsl = requestPermissionK(camera) { //有两种写法,个人更喜欢下面这种不用写=,两个都写只有一个生效 //granted = {} granted { /*同意权限*/ } denied { /*拒绝权限*/ } explained { /*拒绝并且不再显示*/ } 调用 //调用 // single.launch(camera) singleDsl.launch(camera) 申请多个权限 使用方法基本和上面类似，这次全部放在一起。 //ktx 写法 val multiple = requestMultiplePermissions( allGranted = { //全部同意 },denied = { //拒绝 },explained = { //拒绝并不再显示 } ) //dsl val multipleDsl = requestPermissionK { allGranted { } denied { } explained { } } fun applyMultiple(view: View) { // multiple.launch(arrayOf(camera,write)) multipleDsl.launch(arrayOf(camera,write)) } 参考 项目地址 开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法) Jetpack Activity Result API 优雅的实现页面传值 Android 新出功能 ActivityResultContract，真香！ 你好，Activity Results API！ ","link":"https://KiWiLss.github.io/activity-result-api-dsl/"},{"title":"CharSequence 相关扩展收集","content":"前言 主要是关于一些字符串判断相关内容，主要包括判断字符串是否含有空格、是否含有汉字、是否含有字母、是否含有数字、特殊符号等，字符串本身就有很多 Api 可以实现很多功能，但是对于判断方面就少了点，这里把收集到的常用的整理起来，可以直接使用。 函数列表 判断相关 isNotNullOrEmpty :CharSequence不为 null 或者 empty isHasSpecial :是否含有特殊字符,true有，false没有 isHasChinese :是否含有汉字,true有，false没有 isChinese :是否全是汉字 isHasLower :是否含有小写字母,true有，false没有 isLower :是否全是大写字母 isHasCapital :是否含有大写字母,true有，false没有 isCapital :是否全是大写字母 isHasLetter :是否含有字母，不区分大小写，true有，false没有 isLetter :是否全是字母 isHasDigit :是否含有数字，true有，false没有 isDigits :是否全是数字，也可以用isDigitsOnly isDigits2 :是否全是数字，也可以用isDigitsOnly isHasSpace :是否含有空格，true有，false没有 isSpace :是否全是空格 Char.isSpace() :判断字符是否是空格 其他 substringBetween :指定裁剪出str中open和close包含着的那部分字符串 toFirstUpperCase :首字母大写，或者调用capitalize toFirstLowerCase :首字母小写，或者调用decapitalize substringUnDigits :截取非数字，只能截取第一段连续的，不在首位截取不到 substringDigits :截取数字，只能截取第一段连续的数字 substringAllDigits :截取数字，截取所有的数字 stringSize :特定字符串的数量 charSize :含有特定字符的数量 spaceSize :含有空格数量 工具类 object CharSequenceKtx { //匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效 const val SPACE = &quot;[\\\\s]&quot; //匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效 const val UN_SPACE = &quot;[\\\\S]&quot; //数字字符匹配。等效于 [0-9] const val DIGITS = &quot;[\\\\d]&quot; //非数字字符匹配。等效于 [^0-9] const val UN_DIGITS = &quot;[\\\\D]&quot; //匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效 const val DIGITS_LETTER_UNDERLINE = &quot;[\\\\w]&quot; //与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效 const val UN_DIGITS_LETTER = &quot;[\\\\W]&quot; //匹配大写字母 const val UPPERCASE_LETTER = &quot;[A-Z]&quot; //匹配小写字母 const val LOWER_LETTER = &quot;[a-z]&quot; //匹配字母 const val LETTER = &quot;[a-zA-Z]&quot; //匹配字母和数字 const val DIGITS_LETTER = &quot;[a-zA-Z0-9]&quot; //匹配汉字 const val CHINESE = &quot;[\\u4e00-\\u9fa5]&quot; //匹配特殊字符 const val SPECIAL_CHARACTERS = &quot;[ _`~!@#$%^&amp;*()+=|{}':;',\\\\[\\\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。，、？]|\\n|\\r|\\t&quot; } //fun CharSequence?.isBank() = this.isBlank() fun testSpace(): Unit { val test: String = &quot;hello&quot; val test2 = &quot;noSpace&quot; val test3 = &quot; 2321fdf汉字 --9**&amp;&quot; val test4 = &quot; he llo &quot; val test5 = &quot;函数 zifu 2134&quot; println(&quot;----------------&quot;) println(test4.removePrefix(&quot; &quot;))//移除前缀 println(test4.removeSuffix(&quot; &quot;))//移除后缀 /* println(test3.stringSize(&quot;2&quot;)) println(test.stringSize(&quot;2&quot;)) println(test.stringSize(&quot;l&quot;))*/ /* println(test5.replace(Regex(&quot;[\\\\d]&quot;), &quot;*&quot;))//数字替换 println(test5.replace(Regex(CharSequenceKtx.SPACE), &quot;&quot;))//删除所有空格 println(test4.trim()) println(test3.substringBefore(&quot;f&quot;))//截取指定字符串之前的内容*/ /* println(test5.toUpperCase())//字母大写 println(test.capitalize())//首字母大写 println(test2.decapitalize())//首字母小写 println(test2.toLowerCase())//字母小写*/ // println(test5.contains(Regex(CharSequenceKtx.DIGITS))) // println(test5.contains(Regex(CharSequenceKtx.UPPERCASE_LETTER))) /* println(test.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母 println(test2.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母 println(test.contains(Regex(CharSequenceKtx.LOWER_LETTER))) println(test.matches(Regex(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;))) println(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;) println(test5.contains(Regex(CharSequenceKtx.CHINESE))) println(test5.matches(Regex(CharSequenceKtx.CHINESE + &quot;*&quot;)))*/ // println(test2.first().toUpperCase() + test2.substring(1)) //过滤非数字 /* println(test3.filter { it.isDigit() })*/ /* println(test3.substringUnDigits()) println(test2.substringUnDigits())*/ // println(test.substringDigits()) // println(test5.substringDigits()) } /** *CharSequence不为 null 或者 empty */ fun CharSequence?.isNotNullOrEmpty() = !isNullOrEmpty() /** *〈指定裁剪出str中open和close包含着的那部分字符串〉 * @param open * @param close * @return */ fun CharSequence?.substringBetween(open: String?, close: String?): String? { if (isNullOrEmpty() || open.isNullOrEmpty() || close.isNullOrEmpty()) return null val start = this!!.indexOf(open) if (start != -1) { val end = indexOf(close, start + open.length) if (end != -1) { return substring(start + open.length, end) } } return null } fun CharSequence?.substringBetween(tag: String?) = substringBetween(tag, tag) /** *首字母大写，或者调用capitalize * @return */ fun CharSequence.toFirstUpperCase(): CharSequence { if (isEmpty()) { return &quot;&quot; } return first().toUpperCase() + substring(1) } /** *首字母小写，或者调用decapitalize * @return */ fun CharSequence.toFirstLowerCase(): CharSequence { if (isEmpty()) { return &quot;&quot; } return first().toLowerCase() + substring(1) } /** *截取非数字，只能截取第一段连续的，不在首位截取不到 * @return */ fun CharSequence.substringUnDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\D+&quot;) val matcher = pattern.matcher(this) while (matcher.find()) { return matcher.group(0) } return &quot;&quot; } /** *截取数字，只能截取第一段连续的数字 * @return */ fun CharSequence.substringDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\d+&quot;) val matcher = pattern.matcher(this) while (matcher.find()) { return matcher.group(0) } return &quot;&quot; } /** *截取数字，截取所有的数字 * @return */ fun CharSequence.substringAllDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\d+&quot;) val matcher = pattern.matcher(this) val sb = StringBuilder() while (matcher.find()) { sb.append(matcher.group()) } return sb } /** *特定字符串的数量 * @param tag * @return */ fun CharSequence.stringSize(tag: String): Int { return split(tag).size - 1 } /** *含有特定字符的数量 * @param char * @return */ fun CharSequence.charSize(char: Char): Int { var count = 0 forEach { if (it == char) { count++ } } return count } /** *含有空格数量 * @return */ fun CharSequence.spaceSize(): Int { var count = 0 forEach { if (it.isSpace()) { count++ } } return count } /** *是否含有特殊字符,true有，false没有 */ fun CharSequence.isHasSpecial() = contains(Regex(CharSequenceKtx.SPECIAL_CHARACTERS)) /** *是否含有汉字,true有，false没有 */ fun CharSequence.isHasChinese() = contains(Regex(CharSequenceKtx.CHINESE)) /** *是否全是汉字 */ fun CharSequence.isChinese() = matches(Regex(CharSequenceKtx.CHINESE + &quot;+&quot;)) /** *是否含有小写字母,true有，false没有 */ fun CharSequence.isHasLower() = contains(Regex(CharSequenceKtx.LOWER_LETTER)) /** *是否全是大写字母 */ fun CharSequence.isLower() = matches(Regex(CharSequenceKtx.LOWER_LETTER + &quot;+&quot;)) /** *是否含有大写字母,true有，false没有 */ fun CharSequence.isHasCapital() = contains(Regex(CharSequenceKtx.UPPERCASE_LETTER)) /** *是否全是大写字母 */ fun CharSequence.isCapital() = matches(Regex(CharSequenceKtx.UPPERCASE_LETTER + &quot;+&quot;)) /** *是否含有字母，不区分大小写，true有，false没有 */ fun CharSequence.isHasLetter() = contains(Regex(CharSequenceKtx.LETTER)) /** *是否全是字母 */ fun CharSequence.isLetter() = matches(Regex(CharSequenceKtx.LETTER + &quot;+&quot;)) /** *是否含有数字，true有，false没有 */ fun CharSequence.isHasDigit() = contains(Regex(CharSequenceKtx.DIGITS)) /** *是否全是数字，也可以用isDigitsOnly */ fun CharSequence.isDigits() = matches(Regex(CharSequenceKtx.DIGITS + &quot;+&quot;)) /** *是否全都是数字 */ fun CharSequence.isDigits2() = Pattern.compile(&quot;[\\\\d]+&quot;).matcher(this).matches() /** *是否含有空格，true有，false没有 */ fun CharSequence.isHasSpace() = contains(Regex(CharSequenceKtx.SPACE)) /** *是否全是空格 */ fun CharSequence.isSpace() = matches(Regex(CharSequenceKtx.SPACE + &quot;+&quot;)) /** *判断字符是否是空格 */ fun Char.isSpace() = this.toString().isHasSpace() 持续整理中... ","link":"https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/"}]}