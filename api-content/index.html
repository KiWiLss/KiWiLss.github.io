{"posts":[{"title":"Arouter简单封装使用","content":"前言 主要是对ARouter封装使用，只做了简单的封装处理，使用了扩展函数，方便使用，减少重复代码，提高效率。 方法列表 PostCard扩展函数 pretreatment :预处理方法，原ARouter中的实现，不过舍弃了拦截器和自定义callback buildIntent :生成可跳转带参数的 intent navigateForResult :带回调的跳转 RouterKtx扩展函数 startActivityA :普通的跳转 startActivityForResultA :回调跳转 导入依赖 maven { url 'https://www.jitpack.io' } implementation 'com.gitee.quetzalcoatl.ActivityResultApi:arouter:0.0.4' kapt 'com.alibaba:arouter-compiler:1.5.2' 同时在 gradle 中还要加入: id 'kotlin-kapt' kapt { arguments { arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) } } 加入导入后报错，可以试试在project 的gradle.properties 中加入 android.useAndroidX=true android.enableJetifier=true 使用详情 1. PostCard 使用介绍 首先是 PostCard 的使用，这个没有 RouterKtx 用起来方便，不过还是简单介绍一下 ，在 Activitiy/Fragment 中都是调用navigateForResult这个方法，参数和阿里路由传参方法一样，示例如下： ARouter.getInstance().build(RouterPage.ROUTER_ONE) .withString(&quot;key&quot;,&quot;keykeykey&quot;) .navigateForResult(this,99){requestCode, resultCode, data -&gt; Log.e(TAG, &quot;: $requestCode --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } 2. RouterKtx 使用介绍 无参普通跳转 startActivityA(RouterPage.ROUTER_TWO) 使用 Bundle 传参跳转 val bundle = Bundle() bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;) startActivityA(RouterPage.ROUTER_ONE,bundle) 使用 Pair 传参跳转 startActivityA(RouterPage.ROUTER_ONE,&quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88) 无参回调跳转 startActivityForResultA(RouterPage.ROUTER_ONE){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } Bundler 传参回调跳转 val bundle = Bundle() bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;) startActivityForResultA(RouterPage.ROUTER_ONE,bundle){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } Pari 传参回调跳转 startActivityForResultA(RouterPage.ROUTER_ONE, &quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88){resultCode,data-&gt; Log.e(TAG, &quot;: --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; ); } 地址 项目地址 ","link":"https://KiWiLss.github.io/arouter-jian-dan-feng-zhuang-shi-yong/"},{"title":"使用 Fragment 处理 onActivityResult","content":"前言 对Activity和Fragment之间的跳转封装处理，在Activity/Framgent中用法基本一样。每个函数基本上都对应着一个扩展函数，方便调用。实现方式有很多种，可以自由组合，实际使用时按需求使用。 api列表 createIntent :生成Intent并添加参数(可选） createIntentStart :生成跳转的Intent并添加参数,也可以不添加参数 addPair :Intent 添加参数 startActivityK :跳转 startActivityForResultK :带回调的跳转 browse :打开浏览器 share :生调用分享，只能分享文本 email :发送邮件 makeCallPermission :拨打电话，需要权限 makeCall :拨打电话 sendSMS :发送短信 常规跳转startActivity，没有回调 不带任何参数 IntentKtx.startActivityK(this,TvActivity::class.java) IntentKtx.startActivityK&lt;TvActivity&gt;(this) startActivityK&lt;TvActivity&gt;()//扩展函数 前两个是封装函数，第3个是扩展函数，可以直接在Activity好Fragment中调用，在其他地方只要有Context也可以调用扩展函数，方式如下： context.startActivityK&lt;TvActivity&gt;() 使用Intent传参 val intent = Intent(this,TvActivity::class.java) intent.putExtra(&quot;tv&quot;,&quot;one&quot;) intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;) IntentKtx.startActivityK(this,intent) 对应的扩展函数： val intent = Intent(this,TvActivity::class.java) intent.putExtra(&quot;tv&quot;,&quot;one&quot;) intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;) // IntentKtx.startActivityK(this,intent) startActivityK(intent) 更简便的写法： Intent(this,TvActivity::class.java) .addPair(&quot;tv&quot; to &quot;one&quot;, &quot;hai&quot; to &quot;two&quot;) ?.let { startActivityK(it) } 使用Pair传参 //函数 IntentKtx.startActivityK(this,TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //扩展函数 startActivityK(TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //函数 IntentKtx.startActivityK&lt;TvActivity&gt;(this,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) //扩展函数 startActivityK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;) startActivityForResult跳转 使用Fragment处理onActivityResult，网络上有很多开源库都是使用Fragment处理封装。回调result就是onActivityResult里的resultCode, intent就是回传的数据。 无参跳转 ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java){reuslt,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 对应的扩展函数： startActivityForResultK(TvActivity::class.java){ reuslt ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 无参跳转，使用内联函数 ActivityHelper.init(this) ?.startActivityForResult&lt;TvActivity&gt;{reuslt,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;); } 对应的扩展函： startActivityForResultK&lt;TvActivity&gt;{result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---${intent?.getStringExtra(&quot;key&quot;)}&quot;) } 使用Intent携带参数跳转 //带参数跳转,数据放在 intent 里面 /* val intent2 = Intent(this,TvActivity::class.java) intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;) ActivityHelper.init(this) ?.startActivityForResult(intent2){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ //扩展函数 /* val intent2 = Intent(this,TvActivity::class.java) intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;) startActivityForResultK(intent2){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ 使用Pair带参跳转 //pair 传值 /*ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java, &quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ //扩展函数 /* startActivityForResultK(TvActivity::class.java, &quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) }*/ 使用Pair带参跳转，内联函数 //方法一 ActivityHelper.init(this) ?.startActivityForResult(TvActivity::class.java,{result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) },&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;) //方法二 ActivityHelper.init(this) ?.startActivityForResult&lt;TvActivity&gt;(&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) } //扩展函数 startActivityForResultK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt; Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) } 在目标Activity/Fragment使用 在目标Activity/Fragment界面，创建函数实现跳转。这样方便其他人调用跳转，而且不用关心传值的key，也方便以后同意修改。这里面无法直接使用扩展函数，有些方法虽然可以使用，但是并不比扩展函数更方便，这里给出示例，，实现方式有很多种，可以自由组合，实际使用时按需求使用。 companion object{ //这里使用不了扩展函数,简单几个示例,不带回调跳转 //不传参数一般也没必要在这里写，直接使用扩展函数更方便 fun starter(context: Context){ IntentKtx.startActivityK(context,TvActivity::class.java) } fun starter2(context: Context){ IntentKtx.startActivityK&lt;TvActivity&gt;(context) } //一般这种没有必要写在这里，直接用扩展函数跳转就好了 fun starter(context: Context,vararg pair: Pair&lt;String,Any?&gt;){ IntentKtx.startActivityK&lt;TvActivity&gt;(context,*pair) } //这里比较实现这种情况，key值定好，调用的地方直接传对应的参数就行了 fun starter(context: Context,tv: String?,hai: String?){ val intent = Intent(context,TvActivity::class.java) intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai) IntentKtx.startActivityK(context,intent) } //带回调跳转 fun starter(context: Context?,callback: ((Int, Intent?) -&gt; Unit)?){ ActivityHelper.init(context) ?.startActivityForResult&lt;TvActivity&gt;(callback) } //回调也一样，这里比较适合这种情况 fun starter(context: Context?,tv: String?,hai: String?,callback: ((Int, Intent?) -&gt; Unit)?){ val intent = Intent(context,TvActivity::class.java) intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai) ActivityHelper.init(context) ?.startActivityForResult(intent,callback) } //写成下面这样更简洁 fun starter(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){ val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai) ActivityHelper.init(context) ?.startActivityForResult(intent,callback) } //或者写成这样，实现方式有很多，可以自由组合 fun starter2(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){ val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai) context.startActivityForResultK(intent,callback) } } 其他界面调用示例： //调用跳转类的跳转方法 // TvActivity.starter(this) // TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;) //回调跳转 // TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;){result,intent -&gt; // Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;) // } 源码 内容比较简单，只有三个类，约400行代码。复制到代码中即可使用。 RouterFragment class RouterFragment : Fragment() { private val mCallbacks: SparseArray&lt;((Int, Intent?) -&gt; Unit)?&gt; = SparseArray() private val mCodeGenerator: Random = Random() companion object { fun newInstance(): RouterFragment? { return RouterFragment() } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) //防止重复创建 retainInstance = true } fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { val requestCode = makeRequestCode() mCallbacks.put(requestCode, callback) startActivityForResult(intent, requestCode) } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) //处理返回的结果 val callback = mCallbacks[requestCode] mCallbacks.remove(requestCode) callback?.run { invoke(resultCode, data) } } /** * 随机生成唯一的requestCode，最多尝试10次 * @return */ private fun makeRequestCode(): Int { var requestCode: Int var tryCount = 0 do { requestCode = mCodeGenerator.nextInt(0x0000FFFF) tryCount++ } while (mCallbacks.indexOfKey(requestCode) &gt;= 0 &amp;&amp; tryCount &lt; 10) return requestCode } } IntentKtx object IntentKtx { fun addPair(intent: Intent, vararg params: Pair&lt;String, Any?&gt;) { params.forEach { when (val value = it.second) { null -&gt; intent.putExtra(it.first, null as Serializable?) is Int -&gt; intent.putExtra(it.first, value) is Long -&gt; intent.putExtra(it.first, value) is CharSequence -&gt; intent.putExtra(it.first, value) is String -&gt; intent.putExtra(it.first, value) is Float -&gt; intent.putExtra(it.first, value) is Double -&gt; intent.putExtra(it.first, value) is Char -&gt; intent.putExtra(it.first, value) is Short -&gt; intent.putExtra(it.first, value) is Boolean -&gt; intent.putExtra(it.first, value) is Serializable -&gt; intent.putExtra(it.first, value) is Bundle -&gt; intent.putExtra(it.first, value) is Parcelable -&gt; intent.putExtra(it.first, value) is Array&lt;*&gt; -&gt; when { value.isArrayOf&lt;CharSequence&gt;() -&gt; intent.putExtra(it.first, value) value.isArrayOf&lt;String&gt;() -&gt; intent.putExtra(it.first, value) value.isArrayOf&lt;Parcelable&gt;() -&gt; intent.putExtra(it.first, value) else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;) } is IntArray -&gt; intent.putExtra(it.first, value) is LongArray -&gt; intent.putExtra(it.first, value) is FloatArray -&gt; intent.putExtra(it.first, value) is DoubleArray -&gt; intent.putExtra(it.first, value) is CharArray -&gt; intent.putExtra(it.first, value) is ShortArray -&gt; intent.putExtra(it.first, value) is BooleanArray -&gt; intent.putExtra(it.first, value) else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;) } } } /** * 不带回调跳转相关 */ fun startActivityK(context: Context?, clazz: Class&lt;*&gt;) { context?.startActivity(Intent(context, clazz)) } inline fun &lt;reified T&gt; startActivityK(context: Context?) { context?.startActivity(Intent(context, T::class.java)) } fun startActivityK(context: Context?, intent: Intent) { context?.startActivity(intent) } fun startActivityK(context: Context?, clazz: Class&lt;*&gt;, vararg params: Pair&lt;String, Any?&gt;) { context?.run { val intent = Intent(this, clazz) intent.addPair(*params) startActivity(intent) } } inline fun &lt;reified T&gt; startActivityK(context: Context?, vararg params: Pair&lt;String, Any?&gt;) { context?.run { val intent = Intent(this, T::class.java) intent.addPair(*params) startActivity(intent) } } } /** *生成跳转的Intent并添加参数 * @param T * @param pair */ inline fun &lt;reified T&gt; Context.createIntentStart(vararg pair: Pair&lt;String, Any?&gt;) = Intent(this, T::class.java).apply { addPair(*pair) } /** *生成Intent添加参数,也可以不添加 */ fun Context.createIntent(vararg pair: Pair&lt;String, Any?&gt;) = Intent().addPair(*pair) fun Intent?.addPair(vararg params: Pair&lt;String, Any?&gt;): Intent? { return this?.also { IntentKtx.addPair(it, *params) } } /** * 不带回调,无参跳转 */ fun Context?.startActivityK(clazz: Class&lt;*&gt;) { this?.startActivity(Intent(this, clazz)) } inline fun &lt;reified T&gt; Context?.startActivityK() { this?.startActivity(Intent(this, T::class.java)) } /** * 不带回调,带参跳转 */ fun Context?.startActivityK(intent: Intent) { this?.startActivity(intent) } fun Context?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(this, clazz) startActivity(intent.addPair(*pair)) } } inline fun &lt;reified T&gt; Context?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(this, T::class.java) startActivity(intent.addPair(*pair)) } } /** * 不带回调,无参跳转 */ fun Fragment?.startActivityK(clazz: Class&lt;*&gt;) { this?.startActivity(Intent(activity, clazz)) } inline fun &lt;reified T&gt; Fragment?.startActivityK() { this?.startActivity(Intent(activity, T::class.java)) } /** * 不带回调,带参跳转 */ fun Fragment?.startActivityK(intent: Intent) { this?.startActivity(intent) } fun Fragment?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(activity, clazz) startActivity(intent.addPair(*pair)) } } inline fun &lt;reified T&gt; Fragment?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) { this?.run { val intent = Intent(activity, T::class.java) startActivity(intent.addPair(*pair)) } } /** * Context扩展函数跳转 */ fun Context?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult(clazz, callback) } fun Context?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; Context?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this)?.startActivityForResult&lt;T&gt;(callback) } fun Context?.startActivityForResultK( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this) ?.startActivityForResult(clazz, callback, *pair) } inline fun &lt;reified T&gt; Context?.startActivityForResultK( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this) ?.startActivityForResult&lt;T&gt;(callback, *pair) } /** * 上述方法在 fragment 中扩展 */ fun Fragment?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult(clazz, callback) } fun Fragment?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) { ActivityHelper.init(this?.context)?.startActivityForResult&lt;T&gt;(callback) } fun Fragment?.startActivityForResultK( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this?.context) ?.startActivityForResult(clazz, callback, *pair) } inline fun &lt;reified T&gt; Fragment?.startActivityForResultK( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { ActivityHelper.init(this?.context) ?.startActivityForResult&lt;T&gt;(callback, *pair) } ActivityHelper class ActivityHelper private constructor(activity: FragmentActivity) { private val TAG = &quot;MMMK&quot; var mContext: Activity? = null private var mRouterFragment: RouterFragment? = null init { mContext = activity mRouterFragment = getRouterFragment(activity) } companion object { // fun init(activity: FragmentActivity?): ActivityHelper? { // if (activity != null) return ActivityHelper(activity) // return null // } fun init(context: Context?): ActivityHelper? { if (context is FragmentActivity) return ActivityHelper(context) return null } } private fun getRouterFragment(activity: FragmentActivity): RouterFragment? { var routerFragment: RouterFragment? = findRouterFragment(activity) if (routerFragment == null) { //创建 fragment,加入当前 activity routerFragment = RouterFragment.newInstance() val sfm = activity.supportFragmentManager sfm.beginTransaction().add(routerFragment!!, TAG).commitAllowingStateLoss() sfm.executePendingTransactions() } return routerFragment } private fun findRouterFragment(activity: FragmentActivity): RouterFragment? { //通过 tag 获取 fragment return activity.supportFragmentManager.findFragmentByTag(TAG) as RouterFragment? } /** * 对Intent跳转,不带参数 */ fun startActivityForResult( clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { mContext?.run { val intent = Intent(this, clazz) startActivityForResult(intent, callback) } } inline fun &lt;reified T&gt; startActivityForResult(noinline callback: ((Int, Intent?) -&gt; Unit)?) { mContext?.run { val intent = Intent(mContext, T::class.java) startActivityForResult(intent, callback) } } /** *带参数跳转 * @param T * @param pair * @param callback */ inline fun &lt;reified T&gt; startActivityForResult( vararg pair: Pair&lt;String, Any?&gt;, noinline callback: ((Int, Intent?) -&gt; Unit)? ) { if (mContext == null) return val intent = Intent(mContext, T::class.java) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } inline fun &lt;reified T&gt; startActivityForResult( noinline callback: ((Int, Intent?) -&gt; Unit)?, vararg pair: Pair&lt;String, Any?&gt; ) { if (mContext == null) return val intent = Intent(mContext, T::class.java) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } fun startActivityForResult( clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;, callback: ((Int, Intent?) -&gt; Unit)? ) { mContext?.run { val intent = Intent(this, clazz) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } } fun startActivityForResult( clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?, vararg pair: Pair&lt;String, Any?&gt; ) { mContext?.run { val intent = Intent(this, clazz) IntentKtx.addPair(intent, *pair) startActivityForResult(intent, callback) } } /** * 对Intent跳转,带参数 * @param intent 参数提取放入intent中 * @param callback */ fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) { mRouterFragment?.run { startActivityForResult(intent, callback) } } } 导入依赖 不想复制更省事的方法，直接依赖即可。依赖如下： Github上面有详细的文档。 最新版 allprojects { repositories { ... maven { url 'https://www.jitpack.io' } } } dependencies { implementation 'com.github.KiWiLss:LUtils:1.1.0' } 使用前要调用，获取到 Context： object LUtilsConfig{ lateinit var mContext: Context fun init(context: Context) { mContext = context } ","link":"https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/"},{"title":"Activity Result Api DSl","content":"前言 在安卓开发中，跳转和申请权限设计的比较麻烦，网上有很多优秀的库解决这个问题，谷歌对这个问题做了处理，废弃了以前的方法。具体的使用方法可以参考末尾的参考博客。下面是对这些方法做的基本封装，方便使用。 IntentKtx 这个类是对普通跳转的封装，可以用也可以不用，主要是方便实现简单的跳转。都是扩展函数，直接在 Activity/Fragment 中使用即可。 createIntent :生成Intent并添加参数(可选） createIntentStart :生成跳转的Intent并添加参数,也可以不添加参数 addPair :Intent 添加参数 startActivityK :跳转 browse :打开浏览器 share :生调用分享，只能分享文本 email :发送邮件 makeCallPermission :拨打电话，需要权限 makeCall :拨打电话 sendSMS :发送短信 封装使用界面跳转 最新版可以参考官网 Activity,Framgnet。 1.导入依赖 我试了一下只导入最后一个也可以，只是 activity对应的版本不是最新的，如果想两个都是最新的就像下面这样，导入两个就行了。下面是原生的依赖导入： //activity def activity_version = &quot;1.2.3&quot; // Java language implementation // implementation &quot;androidx.activity:activity:$activity_version&quot; // Kotlin api &quot;androidx.activity:activity-ktx:$activity_version&quot; //fragment def fragment_version = &quot;1.3.4&quot; // Java language implementation // implementation &quot;androidx.fragment:fragment:$fragment_version&quot; // Kotlin api &quot;androidx.fragment:fragment-ktx:$fragment_version&quot; 封装后的依赖导入，最新版看最后的项目地址： maven { url 'https://www.jitpack.io' } implementation 'com.gitee.quetzalcoatl:ActivityResultApi:0.0.3' 2.跳转使用 第一步生成 ActivityResultLauncher,在这里面可以监听回调。 private val startTest = startActivityForResultK { //这里是回调,相当于 onActivityResult if (it.resultCode == RESULT_OK){ //获取回传值,这里就是以前的 intent it.data?.run { Toast.makeText(this@MainActivity, &quot;${getStringExtra(&quot;result&quot;)}&quot;, Toast.LENGTH_SHORT).show() } } } 第二步调用跳转 fun testStart(view: View) { //调用跳转 startTest.launch(createIntentStart&lt;WelcomeActivity&gt;(&quot;text&quot; to &quot;这里可以传多个参数&quot;)) } 获取参数，回传信息 这里和以前用法一样，没有变化，示例如下： tvText.text = intent.getStringExtra(&quot;text&quot;) //回传任意值 setResult(RESULT_OK,createIntent(&quot;result&quot; to &quot;hello&quot;)) finish() 申请权限 申请权限和上面使用步骤类似，这里做了两种封装，一个单纯的扩展函数，可以直接调用。另一个对扩展做了封装，可以更方便调用。具体用法看下面。 申请单个权限 和以前一样在清单文件申请权限，这里随便申请两个权限 &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; carme 和 write 就是这两个权限。 提前生成对象ActivityResultLauncher，两种用法看个人更喜欢哪种 //ktx 的用法 val single = requestPermission(camera, granted = { //同意权限 }, denied = { //拒绝权限 }, explained = { //拒绝并且不再显示 }) // dsl 用法, 更好用更省事 val singleDsl = requestPermissionK(camera) { //有两种写法,个人更喜欢下面这种不用写=,两个都写只有一个生效 //granted = {} granted { /*同意权限*/ } denied { /*拒绝权限*/ } explained { /*拒绝并且不再显示*/ } 调用 //调用 // single.launch(camera) singleDsl.launch(camera) 申请多个权限 使用方法基本和上面类似，这次全部放在一起。 //ktx 写法 val multiple = requestMultiplePermissions( allGranted = { //全部同意 },denied = { //拒绝 },explained = { //拒绝并不再显示 } ) //dsl val multipleDsl = requestPermissionK { allGranted { } denied { } explained { } } fun applyMultiple(view: View) { // multiple.launch(arrayOf(camera,write)) multipleDsl.launch(arrayOf(camera,write)) } 参考 项目地址 开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法) Jetpack Activity Result API 优雅的实现页面传值 Android 新出功能 ActivityResultContract，真香！ 你好，Activity Results API！ ","link":"https://KiWiLss.github.io/activity-result-api-dsl/"},{"title":"CharSequence 相关扩展收集","content":"前言 主要是关于一些字符串判断相关内容，主要包括判断字符串是否含有空格、是否含有汉字、是否含有字母、是否含有数字、特殊符号等，字符串本身就有很多 Api 可以实现很多功能，但是对于判断方面就少了点，这里把收集到的常用的整理起来，可以直接使用。 函数列表 判断相关 isNotNullOrEmpty :CharSequence不为 null 或者 empty isHasSpecial :是否含有特殊字符,true有，false没有 isHasChinese :是否含有汉字,true有，false没有 isChinese :是否全是汉字 isHasLower :是否含有小写字母,true有，false没有 isLower :是否全是大写字母 isHasCapital :是否含有大写字母,true有，false没有 isCapital :是否全是大写字母 isHasLetter :是否含有字母，不区分大小写，true有，false没有 isLetter :是否全是字母 isHasDigit :是否含有数字，true有，false没有 isDigits :是否全是数字，也可以用isDigitsOnly isDigits2 :是否全是数字，也可以用isDigitsOnly isHasSpace :是否含有空格，true有，false没有 isSpace :是否全是空格 Char.isSpace() :判断字符是否是空格 其他 substringBetween :指定裁剪出str中open和close包含着的那部分字符串 toFirstUpperCase :首字母大写，或者调用capitalize toFirstLowerCase :首字母小写，或者调用decapitalize substringUnDigits :截取非数字，只能截取第一段连续的，不在首位截取不到 substringDigits :截取数字，只能截取第一段连续的数字 substringAllDigits :截取数字，截取所有的数字 stringSize :特定字符串的数量 charSize :含有特定字符的数量 spaceSize :含有空格数量 工具类 object CharSequenceKtx { //匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效 const val SPACE = &quot;[\\\\s]&quot; //匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效 const val UN_SPACE = &quot;[\\\\S]&quot; //数字字符匹配。等效于 [0-9] const val DIGITS = &quot;[\\\\d]&quot; //非数字字符匹配。等效于 [^0-9] const val UN_DIGITS = &quot;[\\\\D]&quot; //匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效 const val DIGITS_LETTER_UNDERLINE = &quot;[\\\\w]&quot; //与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效 const val UN_DIGITS_LETTER = &quot;[\\\\W]&quot; //匹配大写字母 const val UPPERCASE_LETTER = &quot;[A-Z]&quot; //匹配小写字母 const val LOWER_LETTER = &quot;[a-z]&quot; //匹配字母 const val LETTER = &quot;[a-zA-Z]&quot; //匹配字母和数字 const val DIGITS_LETTER = &quot;[a-zA-Z0-9]&quot; //匹配汉字 const val CHINESE = &quot;[\\u4e00-\\u9fa5]&quot; //匹配特殊字符 const val SPECIAL_CHARACTERS = &quot;[ _`~!@#$%^&amp;*()+=|{}':;',\\\\[\\\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。，、？]|\\n|\\r|\\t&quot; } //fun CharSequence?.isBank() = this.isBlank() fun testSpace(): Unit { val test: String = &quot;hello&quot; val test2 = &quot;noSpace&quot; val test3 = &quot; 2321fdf汉字 --9**&amp;&quot; val test4 = &quot; he llo &quot; val test5 = &quot;函数 zifu 2134&quot; println(&quot;----------------&quot;) println(test4.removePrefix(&quot; &quot;))//移除前缀 println(test4.removeSuffix(&quot; &quot;))//移除后缀 /* println(test3.stringSize(&quot;2&quot;)) println(test.stringSize(&quot;2&quot;)) println(test.stringSize(&quot;l&quot;))*/ /* println(test5.replace(Regex(&quot;[\\\\d]&quot;), &quot;*&quot;))//数字替换 println(test5.replace(Regex(CharSequenceKtx.SPACE), &quot;&quot;))//删除所有空格 println(test4.trim()) println(test3.substringBefore(&quot;f&quot;))//截取指定字符串之前的内容*/ /* println(test5.toUpperCase())//字母大写 println(test.capitalize())//首字母大写 println(test2.decapitalize())//首字母小写 println(test2.toLowerCase())//字母小写*/ // println(test5.contains(Regex(CharSequenceKtx.DIGITS))) // println(test5.contains(Regex(CharSequenceKtx.UPPERCASE_LETTER))) /* println(test.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母 println(test2.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母 println(test.contains(Regex(CharSequenceKtx.LOWER_LETTER))) println(test.matches(Regex(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;))) println(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;) println(test5.contains(Regex(CharSequenceKtx.CHINESE))) println(test5.matches(Regex(CharSequenceKtx.CHINESE + &quot;*&quot;)))*/ // println(test2.first().toUpperCase() + test2.substring(1)) //过滤非数字 /* println(test3.filter { it.isDigit() })*/ /* println(test3.substringUnDigits()) println(test2.substringUnDigits())*/ // println(test.substringDigits()) // println(test5.substringDigits()) } /** *CharSequence不为 null 或者 empty */ fun CharSequence?.isNotNullOrEmpty() = !isNullOrEmpty() /** *〈指定裁剪出str中open和close包含着的那部分字符串〉 * @param open * @param close * @return */ fun CharSequence?.substringBetween(open: String?, close: String?): String? { if (isNullOrEmpty() || open.isNullOrEmpty() || close.isNullOrEmpty()) return null val start = this!!.indexOf(open) if (start != -1) { val end = indexOf(close, start + open.length) if (end != -1) { return substring(start + open.length, end) } } return null } fun CharSequence?.substringBetween(tag: String?) = substringBetween(tag, tag) /** *首字母大写，或者调用capitalize * @return */ fun CharSequence.toFirstUpperCase(): CharSequence { if (isEmpty()) { return &quot;&quot; } return first().toUpperCase() + substring(1) } /** *首字母小写，或者调用decapitalize * @return */ fun CharSequence.toFirstLowerCase(): CharSequence { if (isEmpty()) { return &quot;&quot; } return first().toLowerCase() + substring(1) } /** *截取非数字，只能截取第一段连续的，不在首位截取不到 * @return */ fun CharSequence.substringUnDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\D+&quot;) val matcher = pattern.matcher(this) while (matcher.find()) { return matcher.group(0) } return &quot;&quot; } /** *截取数字，只能截取第一段连续的数字 * @return */ fun CharSequence.substringDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\d+&quot;) val matcher = pattern.matcher(this) while (matcher.find()) { return matcher.group(0) } return &quot;&quot; } /** *截取数字，截取所有的数字 * @return */ fun CharSequence.substringAllDigits(): CharSequence { val pattern = Pattern.compile(&quot;\\\\d+&quot;) val matcher = pattern.matcher(this) val sb = StringBuilder() while (matcher.find()) { sb.append(matcher.group()) } return sb } /** *特定字符串的数量 * @param tag * @return */ fun CharSequence.stringSize(tag: String): Int { return split(tag).size - 1 } /** *含有特定字符的数量 * @param char * @return */ fun CharSequence.charSize(char: Char): Int { var count = 0 forEach { if (it == char) { count++ } } return count } /** *含有空格数量 * @return */ fun CharSequence.spaceSize(): Int { var count = 0 forEach { if (it.isSpace()) { count++ } } return count } /** *是否含有特殊字符,true有，false没有 */ fun CharSequence.isHasSpecial() = contains(Regex(CharSequenceKtx.SPECIAL_CHARACTERS)) /** *是否含有汉字,true有，false没有 */ fun CharSequence.isHasChinese() = contains(Regex(CharSequenceKtx.CHINESE)) /** *是否全是汉字 */ fun CharSequence.isChinese() = matches(Regex(CharSequenceKtx.CHINESE + &quot;+&quot;)) /** *是否含有小写字母,true有，false没有 */ fun CharSequence.isHasLower() = contains(Regex(CharSequenceKtx.LOWER_LETTER)) /** *是否全是大写字母 */ fun CharSequence.isLower() = matches(Regex(CharSequenceKtx.LOWER_LETTER + &quot;+&quot;)) /** *是否含有大写字母,true有，false没有 */ fun CharSequence.isHasCapital() = contains(Regex(CharSequenceKtx.UPPERCASE_LETTER)) /** *是否全是大写字母 */ fun CharSequence.isCapital() = matches(Regex(CharSequenceKtx.UPPERCASE_LETTER + &quot;+&quot;)) /** *是否含有字母，不区分大小写，true有，false没有 */ fun CharSequence.isHasLetter() = contains(Regex(CharSequenceKtx.LETTER)) /** *是否全是字母 */ fun CharSequence.isLetter() = matches(Regex(CharSequenceKtx.LETTER + &quot;+&quot;)) /** *是否含有数字，true有，false没有 */ fun CharSequence.isHasDigit() = contains(Regex(CharSequenceKtx.DIGITS)) /** *是否全是数字，也可以用isDigitsOnly */ fun CharSequence.isDigits() = matches(Regex(CharSequenceKtx.DIGITS + &quot;+&quot;)) /** *是否全都是数字 */ fun CharSequence.isDigits2() = Pattern.compile(&quot;[\\\\d]+&quot;).matcher(this).matches() /** *是否含有空格，true有，false没有 */ fun CharSequence.isHasSpace() = contains(Regex(CharSequenceKtx.SPACE)) /** *是否全是空格 */ fun CharSequence.isSpace() = matches(Regex(CharSequenceKtx.SPACE + &quot;+&quot;)) /** *判断字符是否是空格 */ fun Char.isSpace() = this.toString().isHasSpace() 持续整理中... ","link":"https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/"}]}