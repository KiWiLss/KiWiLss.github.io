<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://KiWiLss.github.io</id>
    <title>KiWiLss</title>
    <updated>2021-08-02T15:51:48.346Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://KiWiLss.github.io"/>
    <link rel="self" href="https://KiWiLss.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://KiWiLss.github.io/images/avatar.png</logo>
    <icon>https://KiWiLss.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, KiWiLss</rights>
    <entry>
        <title type="html"><![CDATA[安卓蓝牙问题汇总]]></title>
        <id>https://KiWiLss.github.io/an-zhuo-lan-ya-wen-ti-hui-zong/</id>
        <link href="https://KiWiLss.github.io/an-zhuo-lan-ya-wen-ti-hui-zong/">
        </link>
        <updated>2021-08-02T15:38:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="概述">概述</h3>
<p>低功耗蓝牙，只对安卓5.0以上有用。列举出蓝牙开发中遇到的大部分问题以及对应的解决方法，有些解决方法尝试后没什么效果，不确定具体原因。实际效果受到手机，蓝牙硬件等影响，测试主要使用的是华为和小米手机，其他手机使用效果不确定。下面的问题是开发中实际遇到的问题，已经在网上搜索到的问题做个汇总。</p>
<h3 id="扫描问题">扫描问题</h3>
<ol>
<li>
<p>扫描尽量不要放在主线程，可以放入子线程。不然有些机型会出现 do too many work in main thread. 个人是在主线程扫描，暂时没有遇到问题。</p>
</li>
<li>
<p>扫描不到设备</p>
<p>先检查蓝牙是否打开，相关权限是否授权，6.0以上需要位置权限，7.0以上需要打开GPS。</p>
</li>
<li>
<p>不要频繁扫描，断开扫描</p>
<p>谷歌未来防止BLE扫描滥用，做了限制，不要在30s内对蓝牙扫描重复开启关闭超过5次。</p>
</li>
<li>
<p>手机退到后台扫描不到设备</p>
<p>安卓8.0以上退到后台息屏后，为了保证省电等原因，如果不设置ScanFilters默认扫不到设备。不过我加了以后，还是没有效果，但是还是加上的好。</p>
<pre><code class="language-kotlincsharp">mScannerSetting = new ScanSettings.Builder()
                    //退到后台时设置扫描模式为低功耗
                    .setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)
                    .build();
            mFilters.add(new ScanFilter.Builder()
                    //过滤扫描蓝牙设备的主服务
                    .setServiceUuid(ParcelUuid.fromString(&quot;0000ffff-0000-1000-8000-00805f9bfffb&quot;))
                    .build());
            mScanner.startScan(mFilters, mScannerSetting, mScannerCallback);
</code></pre>
</li>
<li>
<p>扫描到设备后，在回调中做尽量少的工作，可以把扫描到的设备放到另外一个线程中处理。</p>
</li>
</ol>
<h3 id="连接问题">连接问题</h3>
<ol>
<li>
<p>同时连接多个设备时经常连接不成功</p>
<p>在使用 BluetoothGatt建立连接的时候，在任何时刻都只能最多一个设备在尝试建立连接，如果同时对多个蓝牙设备发起连接，前面的设备连接失败了，后面的设备请求就会被阻塞，不会有任何连接回调。因此对多个设备发起连接请求时，最好建立一个请求队列，前一个设备建立连接，后面请求队列中等待。前面的连接成功，就处理下一个连接，如果连接失败了，立马调用 BluetoothGatt.disconnect()/close() 来释放连接，处理下一个设备请求，释放连接注意事项参考下一个。</p>
</li>
<li>
<p>BluetoothGatt 的 disconnect() 和 close()</p>
<p>任何出错，超时，用完就马上调用disconnect() 和 close(),BluetoothGatt.disconnect() 之后不能要马上BluetoothGatt.close().建议在 BluetoothGattCallback中收到BluetoothGatt.STATE_DISCONNECTED时才BluetoothGatt.close()。</p>
<p>理由：disconnect() 之后调用close()虽然大部分手机调用正常，但存在手机蓝牙连接实际没有断开！！！这个会造成蓝牙资源泄露的问题，甚至蓝牙假死。同时这个最好做一个超时机制来释放连接，避免存在BluetoothGattCallback没有回调的情况。（注：之前有遇到手机在极端情况下没有回调）</p>
<p>当连接断开后要调<code>closeGatt</code> 释放资源，不用调<code>disconnect</code> ，也不要下次复用之前的<code>gatt</code> 来<code>reconnect</code> ，因为有的手机上重连可能会存在问题，比如重连后死活发现不了<code>service</code> 。这种情况下，最好只要断开连接就<code>close gatt</code> ，下次连接时打开全新的<code>gatt</code> ，这样就可以发现<code>service</code> 了。</p>
<p>个人使用中两个方法一起调用了，没有发现过异常情况，也许是测试的手机和次数太少。</p>
</li>
<li>
<p>设备的 gatt 在不用的时候要及时关闭，系统支持的连接数量有限，达到上限后无法建立新的连接。</p>
</li>
<li>
<p>最大连接数</p>
<p>网络上有的是7个，有的是6个，可以参考 <a href="https://stackoverflow.com/questions/41365009/what-is-the-max-concurrent-ble-connections-android-m-can-have">android M+ 可以拥有的最大并发 Ble 连接数是多少</a></p>
</li>
<li>
<p>蓝牙连接可能不稳定，最好支持失败自动重试机制，尤其是连接和发现服务，因为80%的问题都发生在建立连接和发现服务的时候，而且这一块也是最耗时的。</p>
</li>
<li>
<p>BLE 设备的建立和断开连接的操作，例如 <code>BluetoothDevice.connectGatt()</code><br>
, <code>BluetoothGatt.connect()</code> , <code>BluetoothGatt.disconnect()</code><br>
等操作最好都放在主线程中，否则你会遇到很多意想不到的麻烦。<br>
开发建议：对  <code>BluetoothGatt</code><br>
的连接和断开请求，都通过发送消息到 Android 的主线程中，让主线程来执行具体的操作。例如创建一个 <code>new Handler(context.getMainLooper())</code>; ，把消息发送到这个  <code>Handler</code> 中。</p>
</li>
<li>
<p>连接不断开的问题别的BLE程序非法保留连接的设备可能会导致连接不能断开</p>
</li>
<li>
<p>连接成功后发现不了服务及特征值</p>
<p>连接成功后，会进行BluetoothGatt.discoverServices()去发现服务，进而设置特征值等，因为该方法是在主线程中执行的，所以为了连接过程的可靠性，建议不要在该过程中，在主线程中不要处理太多的操作(尤其是频繁绘制操作)。</p>
</li>
<li>
<p>采用BluetoothManager.getConnectedDevices(int profile)来检查当前蓝牙连接的情况</p>
<p>理由：可以用来检测蓝牙资源有没有释放干净，因为避免繁琐的异步通信中容易出差。不过此法返回的连接数为空时，也不代表蓝牙的连接完全释放干净。</p>
</li>
<li>
<p>连接成功后，过一会就断开了</p>
<p>这个问题其实并不主要是客户端的问题，所以不要一味的在代码中找问题了，建议与硬件沟通，让其进行优化，如可以调整设备的连接参数（ConnectionInterval（连接间隔）、SlaveLatency（从设备延迟或者从设备时延）、SupervisionTimeout（超时时间或者监控超时）），这三个参数是低功耗蓝牙中十分重要的连接参数，一起决定了BLE的功耗，一般硬件设备会在APP连接成功时主动去更新一下这三个参数，以保证不同手机的差异性得到一致，但是APP端是没办法控制这三个参数的。</p>
</li>
<li>
<p>连接 api 的使用</p>
<p>发起蓝牙Gatt连接 BluetoothDevice.connectGatt(Context context, boolean autoConnect,<br>
BluetoothGattCallback callback)，这里有一个参数autoConnect，如果为 true<br>
的话，系统就会发起一个后台连接，等到系统发现了一个设备，就会自动连上，通常这个过程是非常慢的。为false 的话，就会直接连接，通常会比较快。同样，BluetoothGatt.connect()只能发起一个后台连接，不是直接连接,所以连接时设置autoConnect参数设置为false，如果想实现重连功能的话，自己去手动实。</p>
</li>
<li>
<p>连接出现133/19之类的非0异常</p>
<p>原因：可能由于首次连接蓝牙后没有释放掉gatt资源导致的蓝牙协议栈异常，从而出现133或257<br>
19等值不为0：由于协议栈，连接建立失败</p>
<p>建议：在onConnectionStateChange()回调中判断，若state非0(连接断开)，调用gatt.close()，手动释放掉gatt相关资源</p>
</li>
<li>
<p>连接之后 onServicesDiscovered不被调用</p>
<p>项目中出现蓝牙连接上之后,始终不进 onServicesDiscovered 回调, mBluetoothGatt.discoverServices() 做如下延时即可。</p>
</li>
<li>
<p>Android 从 4.3(API Level 18) 开始支持低功耗蓝牙，但是只支持作为中心设备 （Central） 模式，这就意味着 Android 设备只能主动扫描和链接其他外围设备 （Peripheral）。从Android 5.0(API Level 21)开始两种模式都支持。BLE 官方文档在  <a href="https://link.jianshu.com?t=https://developer.android.com/guide/topics/connectivity/bluetooth-le.html">这里</a> 。</p>
</li>
</ol>
<h3 id="通信问题">通信问题</h3>
<ol>
<li>
<p>发送数据总是失败</p>
<p>原因：<br>
1、首先确定主服务是否正确，再看设置的读、写特征值是否正确</p>
<p>2、因为BLE发现服务和设置特征、通知等是需要耗时的，所以你并不能连接成功后立马发送数据，可以等到在onDescriptorWrite()回调时，或者手动延迟一段时间再去做发送操作。</p>
</li>
<li>
<p>BLE的特征一次读写最大长度20字节。</p>
</li>
<li>
<p>ble 多次写数据只有一次回调</p>
<p>原因就在于上一次的write操作还没有回调，蓝牙处于busy状态，没有执行更多的蓝牙操作(需要查看源码中的mDeviceBusy)</p>
<p>解决:</p>
<p>方法1： 把多个连续的蓝牙操作（read，write等）放在线程里，并把每个蓝牙操作之间加延迟，sleep（200）类似这样。目的是等待回调完成之后再进行下一个蓝牙操作。</p>
<p>方法2：同步操作，把所有蓝牙操作同步，等待回调之后再进行下一个操作</p>
</li>
<li>
<p>BluetoothGatt.writeCharacteristic（）回调一直是 false</p>
<p>除了上面第3条发送数据过快外，还有一种情况是连接异常导致发送不出数据，经测试只有重新连接了才能发送，重发数据还是会失败。</p>
</li>
</ol>
<h3 id="参考">参考</h3>
<p>网上有很多蓝牙相关的库，但是比较可惜的是很多库都没人维护了，很多年不更新，上面的 issues 也是无人问津，不过对于业务比较简单的蓝牙通信使用起来还是没有问题的，也可以把这些库作为参考。下面是相对来说比较优秀，Star比较多的库推荐。</p>
<p><a href="https://github.com/Jasonchenlijian/Fastble">FastBle</a></p>
<p><a href="https://github.com/dingjikerbo/Android-BluetoothKit">Android-BluetoothKit</a></p>
<p><a href="https://github.com/xiaoyaoyou1212/BLE">Android-BLE</a></p>
<p><a href="https://github.com/a1anwang/okble">okble</a></p>
<p><a href="https://github.com/AlexLiuSheng/EasyBluetoothFrame">EasyBluetoothFrame</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Arouter简单封装使用]]></title>
        <id>https://KiWiLss.github.io/arouter-jian-dan-feng-zhuang-shi-yong/</id>
        <link href="https://KiWiLss.github.io/arouter-jian-dan-feng-zhuang-shi-yong/">
        </link>
        <updated>2021-07-06T15:29:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>主要是对<a href="https://github.com/alibaba/ARouter">ARouter</a>封装使用，只做了简单的封装处理，使用了扩展函数，方便使用，减少重复代码，提高效率。</p>
<h2 id="方法列表">方法列表</h2>
<ul>
<li>PostCard扩展函数</li>
</ul>
<pre><code>pretreatment    :预处理方法，原ARouter中的实现，不过舍弃了拦截器和自定义callback
buildIntent     :生成可跳转带参数的 intent
navigateForResult  :带回调的跳转
</code></pre>
<ul>
<li>RouterKtx扩展函数</li>
</ul>
<pre><code>startActivityA    :普通的跳转
startActivityForResultA  :回调跳转
</code></pre>
<h2 id="导入依赖">导入依赖</h2>
<pre><code>maven { url 'https://www.jitpack.io' }

implementation 'com.gitee.quetzalcoatl.ActivityResultApi:arouter:0.0.4'
kapt 'com.alibaba:arouter-compiler:1.5.2'
</code></pre>
<p>同时在 gradle 中还要加入:</p>
<pre><code>id 'kotlin-kapt'
kapt {
    arguments {
        arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName())
    }
}
</code></pre>
<p>加入导入后报错，可以试试在project 的gradle.properties 中加入</p>
<pre><code>android.useAndroidX=true
android.enableJetifier=true
</code></pre>
<h2 id="使用详情">使用详情</h2>
<h4 id="1-postcard-使用介绍">1. PostCard 使用介绍</h4>
<p>首先是 PostCard 的使用，这个没有 RouterKtx 用起来方便，不过还是简单介绍一下<br>
，在 Activitiy/Fragment 中都是调用navigateForResult这个方法，参数和阿里路由传参方法一样，示例如下：</p>
<pre><code>   ARouter.getInstance().build(RouterPage.ROUTER_ONE)
            .withString(&quot;key&quot;,&quot;keykeykey&quot;)
            .navigateForResult(this,99){requestCode, resultCode, data -&gt;
                Log.e(TAG, &quot;: $requestCode --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; );
            }
</code></pre>
<h4 id="2-routerktx-使用介绍">2. RouterKtx 使用介绍</h4>
<ol>
<li>无参普通跳转</li>
</ol>
<pre><code>startActivityA(RouterPage.ROUTER_TWO)
</code></pre>
<ol start="2">
<li>使用 Bundle 传参跳转</li>
</ol>
<pre><code>val bundle = Bundle()
bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;)
startActivityA(RouterPage.ROUTER_ONE,bundle)
</code></pre>
<ol start="3">
<li>使用 Pair 传参跳转</li>
</ol>
<pre><code>startActivityA(RouterPage.ROUTER_ONE,&quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88)
</code></pre>
<ol start="4">
<li>无参回调跳转</li>
</ol>
<pre><code>startActivityForResultA(RouterPage.ROUTER_ONE){resultCode,data-&gt;
      Log.e(TAG, &quot;:  --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; );
}
</code></pre>
<ol start="5">
<li>Bundler 传参回调跳转</li>
</ol>
<pre><code>val bundle = Bundle()
bundle.putString(&quot;key&quot;,&quot;这是 bundle 传值&quot;)
startActivityForResultA(RouterPage.ROUTER_ONE,bundle){resultCode,data-&gt;
    Log.e(TAG, &quot;:  --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; );
}
</code></pre>
<ol start="6">
<li>Pari 传参回调跳转</li>
</ol>
<pre><code>startActivityForResultA(RouterPage.ROUTER_ONE,
        &quot;key&quot; to &quot;这是 pair 传值&quot;, &quot;key2&quot; to 88){resultCode,data-&gt;
       Log.e(TAG, &quot;:  --- $resultCode ---${data?.getStringExtra(&quot;result&quot;)}&quot; );
}
</code></pre>
<h2 id="地址">地址</h2>
<p><a href="https://gitee.com/quetzalcoatl/ActivityResultApi">项目地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 Fragment 处理 onActivityResult]]></title>
        <id>https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/</id>
        <link href="https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/">
        </link>
        <updated>2021-07-04T08:27:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>对Activity和Fragment之间的跳转封装处理，在Activity/Framgent中用法基本一样。每个函数基本上都对应着一个扩展函数，方便调用。实现方式有很多种，可以自由组合，实际使用时按需求使用。</p>
<h2 id="api列表">api列表</h2>
<pre><code>createIntent        :生成Intent并添加参数(可选）
createIntentStart   :生成跳转的Intent并添加参数,也可以不添加参数
addPair                 :Intent 添加参数
startActivityK          :跳转
startActivityForResultK :带回调的跳转
browse                  :打开浏览器
share                   :生调用分享，只能分享文本
email                   :发送邮件
makeCallPermission  :拨打电话，需要权限
makeCall                :拨打电话
sendSMS                 :发送短信
</code></pre>
<h2 id="常规跳转startactivity没有回调">常规跳转startActivity，没有回调</h2>
<ol>
<li>不带任何参数</li>
</ol>
<pre><code>IntentKtx.startActivityK(this,TvActivity::class.java)
IntentKtx.startActivityK&lt;TvActivity&gt;(this)
startActivityK&lt;TvActivity&gt;()//扩展函数
</code></pre>
<ol>
<li>前两个是封装函数，第3个是扩展函数，可以直接在Activity好Fragment中调用，在其他地方只要有Context也可以调用扩展函数，方式如下：</li>
</ol>
<pre><code>context.startActivityK&lt;TvActivity&gt;()
</code></pre>
<ol start="2">
<li>使用Intent传参</li>
</ol>
<pre><code> val intent = Intent(this,TvActivity::class.java)
 intent.putExtra(&quot;tv&quot;,&quot;one&quot;)
 intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;)
 IntentKtx.startActivityK(this,intent)
</code></pre>
<ol start="2">
<li>对应的扩展函数：</li>
</ol>
<pre><code>  val intent = Intent(this,TvActivity::class.java)
        intent.putExtra(&quot;tv&quot;,&quot;one&quot;)
        intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;)
//        IntentKtx.startActivityK(this,intent)
        startActivityK(intent)
</code></pre>
<ol start="2">
<li>更简便的写法：</li>
</ol>
<pre><code>Intent(this,TvActivity::class.java)
    .addPair(&quot;tv&quot; to &quot;one&quot;, &quot;hai&quot; to &quot;two&quot;)
    ?.let { startActivityK(it) }
</code></pre>
<ol start="3">
<li>使用Pair传参</li>
</ol>
<pre><code>//函数
IntentKtx.startActivityK(this,TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
//扩展函数
startActivityK(TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
</code></pre>
<pre><code>//函数
IntentKtx.startActivityK&lt;TvActivity&gt;(this,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
//扩展函数
startActivityK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
</code></pre>
<h2 id="startactivityforresult跳转">startActivityForResult跳转</h2>
<blockquote>
<p>使用Fragment处理onActivityResult，网络上有很多开源库都是使用Fragment处理封装。回调result就是onActivityResult里的resultCode, intent就是回传的数据。</p>
</blockquote>
<ol>
<li>无参跳转</li>
</ol>
<pre><code>ActivityHelper.init(this)
    ?.startActivityForResult(TvActivity::class.java){reuslt,intent-&gt;
        Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
    }
</code></pre>
<ol>
<li>对应的扩展函数：</li>
</ol>
<pre><code>startActivityForResultK(TvActivity::class.java){ reuslt ,intent-&gt;
            Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
        }
</code></pre>
<ol start="2">
<li>无参跳转，使用内联函数</li>
</ol>
<pre><code>ActivityHelper.init(this)
    ?.startActivityForResult&lt;TvActivity&gt;{reuslt,intent-&gt;
        Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
    }
</code></pre>
<ol start="2">
<li>对应的扩展函：</li>
</ol>
<pre><code>startActivityForResultK&lt;TvActivity&gt;{result ,intent-&gt;
      Log.e(TAG, &quot;btnMainStartListener: $result ---${intent?.getStringExtra(&quot;key&quot;)}&quot;)
  }
</code></pre>
<ol start="3">
<li>使用Intent携带参数跳转</li>
</ol>
<pre><code>  //带参数跳转,数据放在 intent 里面
/*       val intent2 = Intent(this,TvActivity::class.java)
       intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;)
       ActivityHelper.init(this)
           ?.startActivityForResult(intent2){result ,intent-&gt;
               Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
           }*/
  //扩展函数
     /* val intent2 = Intent(this,TvActivity::class.java)
      intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;)
      startActivityForResultK(intent2){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }*/
</code></pre>
<ol start="4">
<li>使用Pair带参跳转</li>
</ol>
<pre><code> //pair 传值
      /*ActivityHelper.init(this)
          ?.startActivityForResult(TvActivity::class.java,
          &quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt;
              Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
          }*/
 //扩展函数
/*      startActivityForResultK(TvActivity::class.java,
          &quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }*/
</code></pre>
<ol start="5">
<li>使用Pair带参跳转，内联函数</li>
</ol>
<pre><code>//方法一  
ActivityHelper.init(this)
      ?.startActivityForResult(TvActivity::class.java,{result ,intent-&gt;
               Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
           },&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;)
 //方法二          
 ActivityHelper.init(this)
            ?.startActivityForResult&lt;TvActivity&gt;(&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt;
                Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
            }
 //扩展函数
  startActivityForResultK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }
</code></pre>
<h2 id="在目标activityfragment使用">在目标Activity/Fragment使用</h2>
<blockquote>
<p>在目标Activity/Fragment界面，创建函数实现跳转。这样方便其他人调用跳转，而且不用关心传值的key，也方便以后同意修改。这里面无法直接使用扩展函数，有些方法虽然可以使用，但是并不比扩展函数更方便，这里给出示例，，实现方式有很多种，可以自由组合，实际使用时按需求使用。</p>
</blockquote>
<pre><code>companion object{
    //这里使用不了扩展函数,简单几个示例,不带回调跳转
    //不传参数一般也没必要在这里写，直接使用扩展函数更方便
    fun starter(context: Context){
        IntentKtx.startActivityK(context,TvActivity::class.java)
    }
    fun starter2(context: Context){
        IntentKtx.startActivityK&lt;TvActivity&gt;(context)
    }
    //一般这种没有必要写在这里，直接用扩展函数跳转就好了
    fun starter(context: Context,vararg pair: Pair&lt;String,Any?&gt;){
        IntentKtx.startActivityK&lt;TvActivity&gt;(context,*pair)
    }
    //这里比较实现这种情况，key值定好，调用的地方直接传对应的参数就行了
    fun starter(context: Context,tv: String?,hai: String?){
        val intent = Intent(context,TvActivity::class.java)
        intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
        IntentKtx.startActivityK(context,intent)
    }
    //带回调跳转
    fun starter(context: Context?,callback: ((Int, Intent?) -&gt; Unit)?){
        ActivityHelper.init(context)
            ?.startActivityForResult&lt;TvActivity&gt;(callback)
    }
    //回调也一样，这里比较适合这种情况
    fun starter(context: Context?,tv: String?,hai: String?,callback: ((Int, Intent?) -&gt; Unit)?){
        val intent = Intent(context,TvActivity::class.java)
        intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
        ActivityHelper.init(context)
            ?.startActivityForResult(intent,callback)
    }
       //写成下面这样更简洁
       fun starter(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){
            val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
            ActivityHelper.init(context)
                ?.startActivityForResult(intent,callback)
        }
        //或者写成这样，实现方式有很多，可以自由组合
        fun starter2(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){
            val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
            context.startActivityForResultK(intent,callback)
        }
}
</code></pre>
<p>其他界面调用示例：</p>
<pre><code>        //调用跳转类的跳转方法
//        TvActivity.starter(this)
//        TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;)
        //回调跳转
//        TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;){result,intent -&gt;
//            Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
//        }
</code></pre>
<h2 id="源码">源码</h2>
<p>内容比较简单，只有三个类，约400行代码。复制到代码中即可使用。</p>
<ul>
<li>RouterFragment</li>
</ul>
<pre><code class="language-kotlin">class RouterFragment : Fragment() {

    private val mCallbacks: SparseArray&lt;((Int, Intent?) -&gt; Unit)?&gt; = SparseArray()

    private val mCodeGenerator: Random = Random()

    companion object {
        fun newInstance(): RouterFragment? {
            return RouterFragment()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        //防止重复创建
        retainInstance = true
    }

    fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
        val requestCode = makeRequestCode()
        mCallbacks.put(requestCode, callback)
        startActivityForResult(intent, requestCode)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        //处理返回的结果
        val callback = mCallbacks[requestCode]
        mCallbacks.remove(requestCode)
        callback?.run {
            invoke(resultCode, data)
        }
    }

    /**
     * 随机生成唯一的requestCode，最多尝试10次
     * @return
     */
    private fun makeRequestCode(): Int {
        var requestCode: Int
        var tryCount = 0
        do {
            requestCode = mCodeGenerator.nextInt(0x0000FFFF)
            tryCount++
        } while (mCallbacks.indexOfKey(requestCode) &gt;= 0 &amp;&amp; tryCount &lt; 10)
        return requestCode
    }


}
</code></pre>
<ul>
<li>IntentKtx</li>
</ul>
<pre><code class="language-kotlin">object IntentKtx {
    fun addPair(intent: Intent, vararg params: Pair&lt;String, Any?&gt;) {
        params.forEach {
            when (val value = it.second) {
                null -&gt; intent.putExtra(it.first, null as Serializable?)
                is Int -&gt; intent.putExtra(it.first, value)
                is Long -&gt; intent.putExtra(it.first, value)
                is CharSequence -&gt; intent.putExtra(it.first, value)
                is String -&gt; intent.putExtra(it.first, value)
                is Float -&gt; intent.putExtra(it.first, value)
                is Double -&gt; intent.putExtra(it.first, value)
                is Char -&gt; intent.putExtra(it.first, value)
                is Short -&gt; intent.putExtra(it.first, value)
                is Boolean -&gt; intent.putExtra(it.first, value)
                is Serializable -&gt; intent.putExtra(it.first, value)
                is Bundle -&gt; intent.putExtra(it.first, value)
                is Parcelable -&gt; intent.putExtra(it.first, value)
                is Array&lt;*&gt; -&gt; when {
                    value.isArrayOf&lt;CharSequence&gt;() -&gt; intent.putExtra(it.first, value)
                    value.isArrayOf&lt;String&gt;() -&gt; intent.putExtra(it.first, value)
                    value.isArrayOf&lt;Parcelable&gt;() -&gt; intent.putExtra(it.first, value)
                    else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;)
                }
                is IntArray -&gt; intent.putExtra(it.first, value)
                is LongArray -&gt; intent.putExtra(it.first, value)
                is FloatArray -&gt; intent.putExtra(it.first, value)
                is DoubleArray -&gt; intent.putExtra(it.first, value)
                is CharArray -&gt; intent.putExtra(it.first, value)
                is ShortArray -&gt; intent.putExtra(it.first, value)
                is BooleanArray -&gt; intent.putExtra(it.first, value)
                else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;)
            }
        }
    }

    /**
     * 不带回调跳转相关
     */
    fun startActivityK(context: Context?, clazz: Class&lt;*&gt;) {
        context?.startActivity(Intent(context, clazz))
    }

    inline fun &lt;reified T&gt; startActivityK(context: Context?) {
        context?.startActivity(Intent(context, T::class.java))
    }

    fun startActivityK(context: Context?, intent: Intent) {
        context?.startActivity(intent)
    }

    fun startActivityK(context: Context?, clazz: Class&lt;*&gt;, vararg params: Pair&lt;String, Any?&gt;) {
        context?.run {
            val intent = Intent(this, clazz)
            intent.addPair(*params)
            startActivity(intent)
        }
    }

    inline fun &lt;reified T&gt; startActivityK(context: Context?, vararg params: Pair&lt;String, Any?&gt;) {
        context?.run {
            val intent = Intent(this, T::class.java)
            intent.addPair(*params)
            startActivity(intent)
        }
    }
}
/**
 *生成跳转的Intent并添加参数
 * @param T
 * @param pair
 */
inline fun &lt;reified T&gt; Context.createIntentStart(vararg pair: Pair&lt;String, Any?&gt;) =
    Intent(this, T::class.java).apply {
        addPair(*pair)
    }

/**
 *生成Intent添加参数,也可以不添加
 */
fun Context.createIntent(vararg pair: Pair&lt;String, Any?&gt;) = Intent().addPair(*pair)

fun Intent?.addPair(vararg params: Pair&lt;String, Any?&gt;): Intent? {
    return this?.also { IntentKtx.addPair(it, *params) }
}

/**
 * 不带回调,无参跳转
 */
fun Context?.startActivityK(clazz: Class&lt;*&gt;) {
    this?.startActivity(Intent(this, clazz))
}

inline fun &lt;reified T&gt; Context?.startActivityK() {
    this?.startActivity(Intent(this, T::class.java))
}

/**
 * 不带回调,带参跳转
 */
fun Context?.startActivityK(intent: Intent) {
    this?.startActivity(intent)
}

fun Context?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(this, clazz)
        startActivity(intent.addPair(*pair))
    }
}

inline fun &lt;reified T&gt; Context?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(this, T::class.java)
        startActivity(intent.addPair(*pair))
    }
}

/**
 * 不带回调,无参跳转
 */
fun Fragment?.startActivityK(clazz: Class&lt;*&gt;) {
    this?.startActivity(Intent(activity, clazz))
}

inline fun &lt;reified T&gt; Fragment?.startActivityK() {
    this?.startActivity(Intent(activity, T::class.java))
}

/**
 * 不带回调,带参跳转
 */
fun Fragment?.startActivityK(intent: Intent) {
    this?.startActivity(intent)
}

fun Fragment?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(activity, clazz)
        startActivity(intent.addPair(*pair))
    }
}

inline fun &lt;reified T&gt; Fragment?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(activity, T::class.java)
        startActivity(intent.addPair(*pair))
    }
}


/**
 * Context扩展函数跳转
 */
fun Context?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult(clazz, callback)
}

fun Context?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult(intent, callback)
}

inline fun &lt;reified T&gt; Context?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult&lt;T&gt;(callback)

}

fun Context?.startActivityForResultK(
    clazz: Class&lt;*&gt;,
    vararg pair: Pair&lt;String, Any?&gt;,
    callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this)
        ?.startActivityForResult(clazz, callback, *pair)
}

inline fun &lt;reified T&gt; Context?.startActivityForResultK(
    vararg pair: Pair&lt;String, Any?&gt;,
    noinline callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this)
        ?.startActivityForResult&lt;T&gt;(callback, *pair)
}


/**
 * 上述方法在 fragment 中扩展
 */
fun Fragment?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult(clazz, callback)
}

fun Fragment?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult(intent, callback)
}

inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult&lt;T&gt;(callback)
}

fun Fragment?.startActivityForResultK(
    clazz: Class&lt;*&gt;,
    vararg pair: Pair&lt;String, Any?&gt;,
    callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this?.context)
        ?.startActivityForResult(clazz, callback, *pair)
}

inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(
    vararg pair: Pair&lt;String, Any?&gt;,
    noinline callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this?.context)
        ?.startActivityForResult&lt;T&gt;(callback, *pair)
}
</code></pre>
<ul>
<li>ActivityHelper</li>
</ul>
<pre><code class="language-kotlin">class ActivityHelper private constructor(activity: FragmentActivity) {
    private val TAG = &quot;MMMK&quot;
    var mContext: Activity? = null
    private var mRouterFragment: RouterFragment? = null

    init {
        mContext = activity
        mRouterFragment = getRouterFragment(activity)
    }

    companion object {
//        fun init(activity: FragmentActivity?): ActivityHelper? {
//            if (activity != null) return ActivityHelper(activity)
//            return null
//        }

        fun init(context: Context?): ActivityHelper? {
            if (context is FragmentActivity) return ActivityHelper(context)
            return null
        }
    }


    private fun getRouterFragment(activity: FragmentActivity): RouterFragment? {
        var routerFragment: RouterFragment? = findRouterFragment(activity)
        if (routerFragment == null) {
            //创建 fragment,加入当前 activity
            routerFragment = RouterFragment.newInstance()
            val sfm = activity.supportFragmentManager
            sfm.beginTransaction().add(routerFragment!!, TAG).commitAllowingStateLoss()
            sfm.executePendingTransactions()
        }
        return routerFragment
    }

    private fun findRouterFragment(activity: FragmentActivity): RouterFragment? {
        //通过 tag 获取 fragment
        return activity.supportFragmentManager.findFragmentByTag(TAG) as RouterFragment?
    }


    /**
     * 对Intent跳转,不带参数
     */
    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            startActivityForResult(intent, callback)
        }
    }

    inline fun &lt;reified T&gt; startActivityForResult(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
        mContext?.run {
            val intent = Intent(mContext, T::class.java)
            startActivityForResult(intent, callback)
        }
    }

    /**
     *带参数跳转
     * @param T
     * @param pair
     * @param callback
     */
    inline fun &lt;reified T&gt; startActivityForResult(
        vararg pair: Pair&lt;String, Any?&gt;,
        noinline callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        if (mContext == null) return
        val intent = Intent(mContext, T::class.java)
        IntentKtx.addPair(intent, *pair)
        startActivityForResult(intent, callback)
    }

    inline fun &lt;reified T&gt; startActivityForResult(
        noinline callback: ((Int, Intent?) -&gt; Unit)?,
        vararg pair: Pair&lt;String, Any?&gt;
    ) {
        if (mContext == null) return
        val intent = Intent(mContext, T::class.java)
        IntentKtx.addPair(intent, *pair)
        startActivityForResult(intent, callback)
    }

    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        vararg pair: Pair&lt;String, Any?&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            IntentKtx.addPair(intent, *pair)
            startActivityForResult(intent, callback)
        }
    }

    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?,
        vararg pair: Pair&lt;String, Any?&gt;
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            IntentKtx.addPair(intent, *pair)
            startActivityForResult(intent, callback)
        }
    }

    /**
     * 对Intent跳转,带参数
     * @param intent  参数提取放入intent中
     * @param callback
     */
    fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
        mRouterFragment?.run {
            startActivityForResult(intent, callback)
        }
    }


}
</code></pre>
<h2 id="导入依赖">导入依赖</h2>
<p>不想复制更省事的方法，直接依赖即可。依赖如下：<br>
<a href="https://github.com/KiWiLss/LUtils">Github</a>上面有详细的文档。<br>
<a href="https://www.jitpack.io/v/KiWiLss/LUtils.svg">最新版</a></p>
<pre><code class="language-kotlin">    allprojects {
        repositories {
            ...
            maven { url 'https://www.jitpack.io' }
        }
    }

dependencies {
            implementation 'com.github.KiWiLss:LUtils:1.1.0'
    }

</code></pre>
<p>使用前要调用，获取到 Context：</p>
<pre><code>object LUtilsConfig{

    lateinit var mContext: Context
    fun init(context: Context) {
        mContext = context
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity Result Api DSl]]></title>
        <id>https://KiWiLss.github.io/activity-result-api-dsl/</id>
        <link href="https://KiWiLss.github.io/activity-result-api-dsl/">
        </link>
        <updated>2021-07-04T08:03:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在安卓开发中，跳转和申请权限设计的比较麻烦，网上有很多优秀的库解决这个问题，谷歌对这个问题做了处理，废弃了以前的方法。具体的使用方法可以参考末尾的参考博客。下面是对这些方法做的基本封装，方便使用。</p>
<h2 id="intentktx">IntentKtx</h2>
<p>这个类是对普通跳转的封装，可以用也可以不用，主要是方便实现简单的跳转。都是扩展函数，直接在 Activity/Fragment 中使用即可。</p>
<pre><code>createIntent            :生成Intent并添加参数(可选）
createIntentStart       :生成跳转的Intent并添加参数,也可以不添加参数
addPair                 :Intent 添加参数
startActivityK          :跳转

browse                  :打开浏览器
share                   :生调用分享，只能分享文本
email                   :发送邮件
makeCallPermission  :拨打电话，需要权限
makeCall                :拨打电话
sendSMS                 :发送短信
</code></pre>
<h2 id="封装使用界面跳转">封装使用界面跳转</h2>
<p>最新版可以参考官网 <a href="https://developer.android.google.cn/jetpack/androidx/releases/activity#kts">Activity</a>,<a href="https://developer.android.google.cn/jetpack/androidx/releases/fragment">Framgnet</a>。</p>
<h3 id="1导入依赖">1.导入依赖</h3>
<p>我试了一下只导入最后一个也可以，只是 activity对应的版本不是最新的，如果想两个都是最新的就像下面这样，导入两个就行了。下面是原生的依赖导入：</p>
<pre><code>   //activity
    def activity_version = &quot;1.2.3&quot;
    // Java language implementation
//    implementation &quot;androidx.activity:activity:$activity_version&quot;
    // Kotlin
    api &quot;androidx.activity:activity-ktx:$activity_version&quot;
    //fragment
    def fragment_version = &quot;1.3.4&quot;
    // Java language implementation
//    implementation &quot;androidx.fragment:fragment:$fragment_version&quot;
    // Kotlin
    api &quot;androidx.fragment:fragment-ktx:$fragment_version&quot;
</code></pre>
<p>封装后的依赖导入，最新版看最后的项目地址：</p>
<pre><code>maven { url 'https://www.jitpack.io' }
 
implementation 'com.gitee.quetzalcoatl:ActivityResultApi:0.0.3'
</code></pre>
<h3 id="2跳转使用">2.跳转使用</h3>
<ol>
<li>第一步生成 ActivityResultLauncher,在这里面可以监听回调。</li>
</ol>
<pre><code>  private val startTest = startActivityForResultK {
        //这里是回调,相当于 onActivityResult
        if (it.resultCode == RESULT_OK){
            //获取回传值,这里就是以前的 intent
            it.data?.run {
                Toast.makeText(this@MainActivity,
                    &quot;${getStringExtra(&quot;result&quot;)}&quot;, Toast.LENGTH_SHORT).show()
            }
        }
    }
</code></pre>
<ol start="2">
<li>第二步调用跳转</li>
</ol>
<pre><code> fun testStart(view: View) {
        //调用跳转
        startTest.launch(createIntentStart&lt;WelcomeActivity&gt;(&quot;text&quot; to &quot;这里可以传多个参数&quot;))
    }
</code></pre>
<ol start="3">
<li>获取参数，回传信息<br>
这里和以前用法一样，没有变化，示例如下：</li>
</ol>
<pre><code>  tvText.text = intent.getStringExtra(&quot;text&quot;)
    //回传任意值
        setResult(RESULT_OK,createIntent(&quot;result&quot; to &quot;hello&quot;))
        finish()
</code></pre>
<h2 id="申请权限">申请权限</h2>
<p>申请权限和上面使用步骤类似，这里做了两种封装，一个单纯的扩展函数，可以直接调用。另一个对扩展做了封装，可以更方便调用。具体用法看下面。</p>
<h3 id="申请单个权限">申请单个权限</h3>
<ol>
<li>和以前一样在清单文件申请权限，这里随便申请两个权限</li>
</ol>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
</code></pre>
<p>carme 和 write 就是这两个权限。</p>
<ol start="2">
<li>提前生成对象ActivityResultLauncher，两种用法看个人更喜欢哪种</li>
</ol>
<pre><code>//ktx 的用法
    val single = requestPermission(camera,
        granted = {
            //同意权限
        }, denied = {
            //拒绝权限
        }, explained = {
            //拒绝并且不再显示
        })
</code></pre>
<pre><code> // dsl 用法, 更好用更省事
    val singleDsl = requestPermissionK(camera) {
        //有两种写法,个人更喜欢下面这种不用写=,两个都写只有一个生效
        //granted = {}
        granted { /*同意权限*/ }
        denied { /*拒绝权限*/ }
        explained { /*拒绝并且不再显示*/ }
</code></pre>
<ol start="3">
<li>调用</li>
</ol>
<pre><code>//调用
//        single.launch(camera)
        singleDsl.launch(camera)
</code></pre>
<h3 id="申请多个权限">申请多个权限</h3>
<p>使用方法基本和上面类似，这次全部放在一起。</p>
<pre><code>  //ktx 写法
    val multiple = requestMultiplePermissions(
        allGranted = {
            //全部同意
        },denied = {
            //拒绝
        },explained = {
            //拒绝并不再显示
        }
    )
    //dsl
    val multipleDsl = requestPermissionK {
        allGranted {  }
        denied {  }
        explained {  }
    }
    fun applyMultiple(view: View) {
//        multiple.launch(arrayOf(camera,write))
        multipleDsl.launch(arrayOf(camera,write))
    }
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://gitee.com/quetzalcoatl/ActivityResultApi">项目地址</a></p>
<p><a href="https://juejin.cn/post/6844904200644591630">开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法)</a></p>
<p><a href="https://www.jianshu.com/p/b18a57a497b3">Jetpack Activity Result API 优雅的实现页面传值</a></p>
<p><a href="https://mp.weixin.qq.com/s/r_9x7-48_tD-cFOX07GDfA">Android 新出功能 ActivityResultContract，真香！</a></p>
<p><a href="https://mp.weixin.qq.com/s/jcnFN73d002OfRXRx6u3yA">你好，Activity Results API！</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CharSequence 相关扩展收集]]></title>
        <id>https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/</id>
        <link href="https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/">
        </link>
        <updated>2021-07-04T07:47:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>主要是关于一些字符串判断相关内容，<strong>主要包括判断字符串是否含有空格、是否含有汉字、是否含有字母、是否含有数字、特殊符号</strong>等，字符串本身就有很多 Api 可以实现很多功能，但是对于判断方面就少了点，这里把收集到的常用的整理起来，可以直接使用。</p>
<h2 id="函数列表">函数列表</h2>
<ul>
<li>判断相关</li>
</ul>
<pre><code class="language-kotlin">isNotNullOrEmpty		:CharSequence不为 null 或者 empty
isHasSpecial			:是否含有特殊字符,true有，false没有
isHasChinese			:是否含有汉字,true有，false没有
isChinese				:是否全是汉字
isHasLower				:是否含有小写字母,true有，false没有
isLower					:是否全是大写字母
isHasCapital			:是否含有大写字母,true有，false没有
isCapital				:是否全是大写字母
isHasLetter				:是否含有字母，不区分大小写，true有，false没有
isLetter				:是否全是字母
isHasDigit				:是否含有数字，true有，false没有
isDigits				:是否全是数字，也可以用isDigitsOnly
isDigits2				:是否全是数字，也可以用isDigitsOnly
isHasSpace				:是否含有空格，true有，false没有
isSpace					:是否全是空格

Char.isSpace()			:判断字符是否是空格
</code></pre>
<ul>
<li>其他</li>
</ul>
<pre><code class="language-kotlin">
substringBetween		:指定裁剪出str中open和close包含着的那部分字符串
toFirstUpperCase		:首字母大写，或者调用capitalize
toFirstLowerCase		:首字母小写，或者调用decapitalize
substringUnDigits		:截取非数字，只能截取第一段连续的，不在首位截取不到
substringDigits			:截取数字，只能截取第一段连续的数字
substringAllDigits		:截取数字，截取所有的数字
stringSize				:特定字符串的数量
charSize				:含有特定字符的数量
spaceSize				:含有空格数量
</code></pre>
<h2 id="工具类">工具类</h2>
<pre><code class="language-kotlin">object CharSequenceKtx {
    //匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效
    const val SPACE = &quot;[\\s]&quot;

    //匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效
    const val UN_SPACE = &quot;[\\S]&quot;

    //数字字符匹配。等效于 [0-9]
    const val DIGITS = &quot;[\\d]&quot;

    //非数字字符匹配。等效于 [^0-9]
    const val UN_DIGITS = &quot;[\\D]&quot;

    //匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效
    const val DIGITS_LETTER_UNDERLINE = &quot;[\\w]&quot;

    //与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效
    const val UN_DIGITS_LETTER = &quot;[\\W]&quot;

    //匹配大写字母
    const val UPPERCASE_LETTER = &quot;[A-Z]&quot;

    //匹配小写字母
    const val LOWER_LETTER = &quot;[a-z]&quot;

    //匹配字母
    const val LETTER = &quot;[a-zA-Z]&quot;

    //匹配字母和数字
    const val DIGITS_LETTER = &quot;[a-zA-Z0-9]&quot;

    //匹配汉字
    const val CHINESE = &quot;[\u4e00-\u9fa5]&quot;

    //匹配特殊字符
    const val SPECIAL_CHARACTERS =
        &quot;[ _`~!@#$%^&amp;*()+=|{}':;',\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。，、？]|\n|\r|\t&quot;
}

//fun CharSequence?.isBank() = this.isBlank()


fun testSpace(): Unit {
    val test: String = &quot;hello&quot;
    val test2 = &quot;noSpace&quot;
    val test3 = &quot; 2321fdf汉字 --9**&amp;&quot;
    val test4 = &quot; he llo &quot;
    val test5 = &quot;函数 zifu 2134&quot;
    println(&quot;----------------&quot;)

    println(test4.removePrefix(&quot; &quot;))//移除前缀
    println(test4.removeSuffix(&quot; &quot;))//移除后缀
/*    println(test3.stringSize(&quot;2&quot;))
    println(test.stringSize(&quot;2&quot;))
    println(test.stringSize(&quot;l&quot;))*/

/*    println(test5.replace(Regex(&quot;[\\d]&quot;), &quot;*&quot;))//数字替换

    println(test5.replace(Regex(CharSequenceKtx.SPACE), &quot;&quot;))//删除所有空格
    println(test4.trim())
    println(test3.substringBefore(&quot;f&quot;))//截取指定字符串之前的内容*/


/*    println(test5.toUpperCase())//字母大写
    println(test.capitalize())//首字母大写
    println(test2.decapitalize())//首字母小写
    println(test2.toLowerCase())//字母小写*/

//    println(test5.contains(Regex(CharSequenceKtx.DIGITS)))
//    println(test5.contains(Regex(CharSequenceKtx.UPPERCASE_LETTER)))
/*    println(test.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母
    println(test2.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母

    println(test.contains(Regex(CharSequenceKtx.LOWER_LETTER)))
    println(test.matches(Regex(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;)))
    println(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;)
    println(test5.contains(Regex(CharSequenceKtx.CHINESE)))
    println(test5.matches(Regex(CharSequenceKtx.CHINESE + &quot;*&quot;)))*/
//    println(test2.first().toUpperCase() + test2.substring(1))
    //过滤非数字
    /*  println(test3.filter {
          it.isDigit()
      })*/
    /*  println(test3.substringUnDigits())
      println(test2.substringUnDigits())*/
//    println(test.substringDigits())
//    println(test5.substringDigits())

}

/**
 *CharSequence不为 null 或者 empty
 */
fun CharSequence?.isNotNullOrEmpty() = !isNullOrEmpty()

/**
 *〈指定裁剪出str中open和close包含着的那部分字符串〉
 * @param open
 * @param close
 * @return
 */
fun CharSequence?.substringBetween(open: String?, close: String?): String? {
    if (isNullOrEmpty() || open.isNullOrEmpty() || close.isNullOrEmpty()) return null
    val start = this!!.indexOf(open)
    if (start != -1) {
        val end = indexOf(close, start + open.length)
        if (end != -1) {
            return substring(start + open.length, end)
        }
    }
    return null
}

fun CharSequence?.substringBetween(tag: String?) = substringBetween(tag, tag)

/**
 *首字母大写，或者调用capitalize
 * @return
 */
fun CharSequence.toFirstUpperCase(): CharSequence {
    if (isEmpty()) {
        return &quot;&quot;
    }
    return first().toUpperCase() + substring(1)
}

/**
 *首字母小写，或者调用decapitalize
 * @return
 */
fun CharSequence.toFirstLowerCase(): CharSequence {
    if (isEmpty()) {
        return &quot;&quot;
    }
    return first().toLowerCase() + substring(1)
}

/**
 *截取非数字，只能截取第一段连续的，不在首位截取不到
 * @return
 */
fun CharSequence.substringUnDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\D+&quot;)
    val matcher = pattern.matcher(this)
    while (matcher.find()) {
        return matcher.group(0)
    }
    return &quot;&quot;
}

/**
 *截取数字，只能截取第一段连续的数字
 * @return
 */
fun CharSequence.substringDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\d+&quot;)
    val matcher = pattern.matcher(this)
    while (matcher.find()) {
        return matcher.group(0)
    }
    return &quot;&quot;
}

/**
 *截取数字，截取所有的数字
 * @return
 */
fun CharSequence.substringAllDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\d+&quot;)
    val matcher = pattern.matcher(this)
    val sb = StringBuilder()
    while (matcher.find()) {
        sb.append(matcher.group())
    }
    return sb
}

/**
 *特定字符串的数量
 * @param tag
 * @return
 */
fun CharSequence.stringSize(tag: String): Int {
    return split(tag).size - 1
}

/**
 *含有特定字符的数量
 * @param char
 * @return
 */
fun CharSequence.charSize(char: Char): Int {
    var count = 0
    forEach {
        if (it == char) {
            count++
        }
    }
    return count
}

/**
 *含有空格数量
 * @return
 */
fun CharSequence.spaceSize(): Int {
    var count = 0
    forEach {
        if (it.isSpace()) {
            count++
        }
    }
    return count
}

/**
 *是否含有特殊字符,true有，false没有
 */
fun CharSequence.isHasSpecial() = contains(Regex(CharSequenceKtx.SPECIAL_CHARACTERS))

/**
 *是否含有汉字,true有，false没有
 */
fun CharSequence.isHasChinese() = contains(Regex(CharSequenceKtx.CHINESE))

/**
 *是否全是汉字
 */
fun CharSequence.isChinese() = matches(Regex(CharSequenceKtx.CHINESE + &quot;+&quot;))

/**
 *是否含有小写字母,true有，false没有
 */
fun CharSequence.isHasLower() = contains(Regex(CharSequenceKtx.LOWER_LETTER))

/**
 *是否全是大写字母
 */
fun CharSequence.isLower() = matches(Regex(CharSequenceKtx.LOWER_LETTER + &quot;+&quot;))

/**
 *是否含有大写字母,true有，false没有
 */
fun CharSequence.isHasCapital() = contains(Regex(CharSequenceKtx.UPPERCASE_LETTER))

/**
 *是否全是大写字母
 */
fun CharSequence.isCapital() = matches(Regex(CharSequenceKtx.UPPERCASE_LETTER + &quot;+&quot;))

/**
 *是否含有字母，不区分大小写，true有，false没有
 */
fun CharSequence.isHasLetter() = contains(Regex(CharSequenceKtx.LETTER))

/**
 *是否全是字母
 */
fun CharSequence.isLetter() = matches(Regex(CharSequenceKtx.LETTER + &quot;+&quot;))

/**
 *是否含有数字，true有，false没有
 */
fun CharSequence.isHasDigit() = contains(Regex(CharSequenceKtx.DIGITS))

/**
 *是否全是数字，也可以用isDigitsOnly
 */
fun CharSequence.isDigits() = matches(Regex(CharSequenceKtx.DIGITS + &quot;+&quot;))

/**
 *是否全都是数字
 */
fun CharSequence.isDigits2() = Pattern.compile(&quot;[\\d]+&quot;).matcher(this).matches()

/**
 *是否含有空格，true有，false没有
 */
fun CharSequence.isHasSpace() = contains(Regex(CharSequenceKtx.SPACE))

/**
 *是否全是空格
 */
fun CharSequence.isSpace() = matches(Regex(CharSequenceKtx.SPACE + &quot;+&quot;))

/**
 *判断字符是否是空格
 */
fun Char.isSpace() = this.toString().isHasSpace()
</code></pre>
<p>持续整理中...</p>
]]></content>
    </entry>
</feed>