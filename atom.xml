<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://KiWiLss.github.io</id>
    <title>KiWiLss</title>
    <updated>2021-07-04T08:47:41.581Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://KiWiLss.github.io"/>
    <link rel="self" href="https://KiWiLss.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://KiWiLss.github.io/images/avatar.png</logo>
    <icon>https://KiWiLss.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, KiWiLss</rights>
    <entry>
        <title type="html"><![CDATA[使用 Fragment 处理 onActivityResult]]></title>
        <id>https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/</id>
        <link href="https://KiWiLss.github.io/shi-yong-fragment-chu-li-onactivityresult/">
        </link>
        <updated>2021-07-04T08:27:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>对Activity和Fragment之间的跳转封装处理，在Activity/Framgent中用法基本一样。每个函数基本上都对应着一个扩展函数，方便调用。实现方式有很多种，可以自由组合，实际使用时按需求使用。</p>
<h2 id="api列表">api列表</h2>
<pre><code>createIntent        :生成Intent并添加参数(可选）
createIntentStart   :生成跳转的Intent并添加参数,也可以不添加参数
addPair                 :Intent 添加参数
startActivityK          :跳转
startActivityForResultK :带回调的跳转
browse                  :打开浏览器
share                   :生调用分享，只能分享文本
email                   :发送邮件
makeCallPermission  :拨打电话，需要权限
makeCall                :拨打电话
sendSMS                 :发送短信
</code></pre>
<h2 id="常规跳转startactivity没有回调">常规跳转startActivity，没有回调</h2>
<ol>
<li>不带任何参数</li>
</ol>
<pre><code>IntentKtx.startActivityK(this,TvActivity::class.java)
IntentKtx.startActivityK&lt;TvActivity&gt;(this)
startActivityK&lt;TvActivity&gt;()//扩展函数
</code></pre>
<ol>
<li>前两个是封装函数，第3个是扩展函数，可以直接在Activity好Fragment中调用，在其他地方只要有Context也可以调用扩展函数，方式如下：</li>
</ol>
<pre><code>context.startActivityK&lt;TvActivity&gt;()
</code></pre>
<ol start="2">
<li>使用Intent传参</li>
</ol>
<pre><code> val intent = Intent(this,TvActivity::class.java)
 intent.putExtra(&quot;tv&quot;,&quot;one&quot;)
 intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;)
 IntentKtx.startActivityK(this,intent)
</code></pre>
<ol start="2">
<li>对应的扩展函数：</li>
</ol>
<pre><code>  val intent = Intent(this,TvActivity::class.java)
        intent.putExtra(&quot;tv&quot;,&quot;one&quot;)
        intent.putExtra(&quot;hai&quot;,&quot;hai---&quot;)
//        IntentKtx.startActivityK(this,intent)
        startActivityK(intent)
</code></pre>
<ol start="2">
<li>更简便的写法：</li>
</ol>
<pre><code>Intent(this,TvActivity::class.java)
    .addPair(&quot;tv&quot; to &quot;one&quot;, &quot;hai&quot; to &quot;two&quot;)
    ?.let { startActivityK(it) }
</code></pre>
<ol start="3">
<li>使用Pair传参</li>
</ol>
<pre><code>//函数
IntentKtx.startActivityK(this,TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
//扩展函数
startActivityK(TvActivity::class.java,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
</code></pre>
<pre><code>//函数
IntentKtx.startActivityK&lt;TvActivity&gt;(this,&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
//扩展函数
startActivityK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;one&quot;,&quot;hai&quot; to &quot;hello&quot;)
</code></pre>
<h2 id="startactivityforresult跳转">startActivityForResult跳转</h2>
<blockquote>
<p>使用Fragment处理onActivityResult，网络上有很多开源库都是使用Fragment处理封装。回调result就是onActivityResult里的resultCode, intent就是回传的数据。</p>
</blockquote>
<ol>
<li>无参跳转</li>
</ol>
<pre><code>ActivityHelper.init(this)
    ?.startActivityForResult(TvActivity::class.java){reuslt,intent-&gt;
        Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
    }
</code></pre>
<ol>
<li>对应的扩展函数：</li>
</ol>
<pre><code>startActivityForResultK(TvActivity::class.java){ reuslt ,intent-&gt;
            Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
        }
</code></pre>
<ol start="2">
<li>无参跳转，使用内联函数</li>
</ol>
<pre><code>ActivityHelper.init(this)
    ?.startActivityForResult&lt;TvActivity&gt;{reuslt,intent-&gt;
        Log.e(TAG, &quot;btnMainStartListener: $reuslt ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;);
    }
</code></pre>
<ol start="2">
<li>对应的扩展函：</li>
</ol>
<pre><code>startActivityForResultK&lt;TvActivity&gt;{result ,intent-&gt;
      Log.e(TAG, &quot;btnMainStartListener: $result ---${intent?.getStringExtra(&quot;key&quot;)}&quot;)
  }
</code></pre>
<ol start="3">
<li>使用Intent携带参数跳转</li>
</ol>
<pre><code>  //带参数跳转,数据放在 intent 里面
/*       val intent2 = Intent(this,TvActivity::class.java)
       intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;)
       ActivityHelper.init(this)
           ?.startActivityForResult(intent2){result ,intent-&gt;
               Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
           }*/
  //扩展函数
     /* val intent2 = Intent(this,TvActivity::class.java)
      intent2.putExtra(&quot;tv&quot;,&quot;key one&quot;)
      startActivityForResultK(intent2){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }*/
</code></pre>
<ol start="4">
<li>使用Pair带参跳转</li>
</ol>
<pre><code> //pair 传值
      /*ActivityHelper.init(this)
          ?.startActivityForResult(TvActivity::class.java,
          &quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt;
              Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
          }*/
 //扩展函数
/*      startActivityForResultK(TvActivity::class.java,
          &quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }*/
</code></pre>
<ol start="5">
<li>使用Pair带参跳转，内联函数</li>
</ol>
<pre><code>//方法一  
ActivityHelper.init(this)
      ?.startActivityForResult(TvActivity::class.java,{result ,intent-&gt;
               Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
           },&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;)
 //方法二          
 ActivityHelper.init(this)
            ?.startActivityForResult&lt;TvActivity&gt;(&quot;key&quot; to &quot;key one&quot;, &quot;key2&quot; to &quot;key two&quot;){result ,intent-&gt;
                Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
            }
 //扩展函数
  startActivityForResultK&lt;TvActivity&gt;(&quot;tv&quot; to &quot;key one&quot;, &quot;hai&quot; to &quot;key two&quot;){result ,intent-&gt;
          Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
      }
</code></pre>
<h2 id="在目标activityfragment使用">在目标Activity/Fragment使用</h2>
<blockquote>
<p>在目标Activity/Fragment界面，创建函数实现跳转。这样方便其他人调用跳转，而且不用关心传值的key，也方便以后同意修改。这里面无法直接使用扩展函数，有些方法虽然可以使用，但是并不比扩展函数更方便，这里给出示例，，实现方式有很多种，可以自由组合，实际使用时按需求使用。</p>
</blockquote>
<pre><code>companion object{
    //这里使用不了扩展函数,简单几个示例,不带回调跳转
    //不传参数一般也没必要在这里写，直接使用扩展函数更方便
    fun starter(context: Context){
        IntentKtx.startActivityK(context,TvActivity::class.java)
    }
    fun starter2(context: Context){
        IntentKtx.startActivityK&lt;TvActivity&gt;(context)
    }
    //一般这种没有必要写在这里，直接用扩展函数跳转就好了
    fun starter(context: Context,vararg pair: Pair&lt;String,Any?&gt;){
        IntentKtx.startActivityK&lt;TvActivity&gt;(context,*pair)
    }
    //这里比较实现这种情况，key值定好，调用的地方直接传对应的参数就行了
    fun starter(context: Context,tv: String?,hai: String?){
        val intent = Intent(context,TvActivity::class.java)
        intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
        IntentKtx.startActivityK(context,intent)
    }
    //带回调跳转
    fun starter(context: Context?,callback: ((Int, Intent?) -&gt; Unit)?){
        ActivityHelper.init(context)
            ?.startActivityForResult&lt;TvActivity&gt;(callback)
    }
    //回调也一样，这里比较适合这种情况
    fun starter(context: Context?,tv: String?,hai: String?,callback: ((Int, Intent?) -&gt; Unit)?){
        val intent = Intent(context,TvActivity::class.java)
        intent.addPair(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
        ActivityHelper.init(context)
            ?.startActivityForResult(intent,callback)
    }
       //写成下面这样更简洁
       fun starter(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){
            val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
            ActivityHelper.init(context)
                ?.startActivityForResult(intent,callback)
        }
        //或者写成这样，实现方式有很多，可以自由组合
        fun starter2(context: Context, tv: String?, hai: String?, callback: ((Int, Intent?) -&gt; Unit)?){
            val intent = context.createIntent&lt;TextViewActivity&gt;(&quot;tv&quot; to tv, &quot;hai&quot; to hai)
            context.startActivityForResultK(intent,callback)
        }
}
</code></pre>
<p>其他界面调用示例：</p>
<pre><code>        //调用跳转类的跳转方法
//        TvActivity.starter(this)
//        TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;)
        //回调跳转
//        TvActivity.starter(this,&quot;one&quot;,&quot;two&quot;){result,intent -&gt;
//            Log.e(TAG, &quot;btnMainStartListener: $result ---- ${intent?.getStringExtra(&quot;key&quot;)}&quot;)
//        }
</code></pre>
<h2 id="源码">源码</h2>
<p>内容比较简单，只有三个类，约400行代码。复制到代码中即可使用。</p>
<ul>
<li>RouterFragment</li>
</ul>
<pre><code class="language-kotlin">class RouterFragment : Fragment() {

    private val mCallbacks: SparseArray&lt;((Int, Intent?) -&gt; Unit)?&gt; = SparseArray()

    private val mCodeGenerator: Random = Random()

    companion object {
        fun newInstance(): RouterFragment? {
            return RouterFragment()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        //防止重复创建
        retainInstance = true
    }

    fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
        val requestCode = makeRequestCode()
        mCallbacks.put(requestCode, callback)
        startActivityForResult(intent, requestCode)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        //处理返回的结果
        val callback = mCallbacks[requestCode]
        mCallbacks.remove(requestCode)
        callback?.run {
            invoke(resultCode, data)
        }
    }

    /**
     * 随机生成唯一的requestCode，最多尝试10次
     * @return
     */
    private fun makeRequestCode(): Int {
        var requestCode: Int
        var tryCount = 0
        do {
            requestCode = mCodeGenerator.nextInt(0x0000FFFF)
            tryCount++
        } while (mCallbacks.indexOfKey(requestCode) &gt;= 0 &amp;&amp; tryCount &lt; 10)
        return requestCode
    }


}
</code></pre>
<ul>
<li>IntentKtx</li>
</ul>
<pre><code class="language-kotlin">object IntentKtx {
    fun addPair(intent: Intent, vararg params: Pair&lt;String, Any?&gt;) {
        params.forEach {
            when (val value = it.second) {
                null -&gt; intent.putExtra(it.first, null as Serializable?)
                is Int -&gt; intent.putExtra(it.first, value)
                is Long -&gt; intent.putExtra(it.first, value)
                is CharSequence -&gt; intent.putExtra(it.first, value)
                is String -&gt; intent.putExtra(it.first, value)
                is Float -&gt; intent.putExtra(it.first, value)
                is Double -&gt; intent.putExtra(it.first, value)
                is Char -&gt; intent.putExtra(it.first, value)
                is Short -&gt; intent.putExtra(it.first, value)
                is Boolean -&gt; intent.putExtra(it.first, value)
                is Serializable -&gt; intent.putExtra(it.first, value)
                is Bundle -&gt; intent.putExtra(it.first, value)
                is Parcelable -&gt; intent.putExtra(it.first, value)
                is Array&lt;*&gt; -&gt; when {
                    value.isArrayOf&lt;CharSequence&gt;() -&gt; intent.putExtra(it.first, value)
                    value.isArrayOf&lt;String&gt;() -&gt; intent.putExtra(it.first, value)
                    value.isArrayOf&lt;Parcelable&gt;() -&gt; intent.putExtra(it.first, value)
                    else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;)
                }
                is IntArray -&gt; intent.putExtra(it.first, value)
                is LongArray -&gt; intent.putExtra(it.first, value)
                is FloatArray -&gt; intent.putExtra(it.first, value)
                is DoubleArray -&gt; intent.putExtra(it.first, value)
                is CharArray -&gt; intent.putExtra(it.first, value)
                is ShortArray -&gt; intent.putExtra(it.first, value)
                is BooleanArray -&gt; intent.putExtra(it.first, value)
                else -&gt; throw Exception(&quot;Intent extra ${it.first} has wrong type ${value.javaClass.name}&quot;)
            }
        }
    }

    /**
     * 不带回调跳转相关
     */
    fun startActivityK(context: Context?, clazz: Class&lt;*&gt;) {
        context?.startActivity(Intent(context, clazz))
    }

    inline fun &lt;reified T&gt; startActivityK(context: Context?) {
        context?.startActivity(Intent(context, T::class.java))
    }

    fun startActivityK(context: Context?, intent: Intent) {
        context?.startActivity(intent)
    }

    fun startActivityK(context: Context?, clazz: Class&lt;*&gt;, vararg params: Pair&lt;String, Any?&gt;) {
        context?.run {
            val intent = Intent(this, clazz)
            intent.addPair(*params)
            startActivity(intent)
        }
    }

    inline fun &lt;reified T&gt; startActivityK(context: Context?, vararg params: Pair&lt;String, Any?&gt;) {
        context?.run {
            val intent = Intent(this, T::class.java)
            intent.addPair(*params)
            startActivity(intent)
        }
    }
}
/**
 *生成跳转的Intent并添加参数
 * @param T
 * @param pair
 */
inline fun &lt;reified T&gt; Context.createIntentStart(vararg pair: Pair&lt;String, Any?&gt;) =
    Intent(this, T::class.java).apply {
        addPair(*pair)
    }

/**
 *生成Intent添加参数,也可以不添加
 */
fun Context.createIntent(vararg pair: Pair&lt;String, Any?&gt;) = Intent().addPair(*pair)

fun Intent?.addPair(vararg params: Pair&lt;String, Any?&gt;): Intent? {
    return this?.also { IntentKtx.addPair(it, *params) }
}

/**
 * 不带回调,无参跳转
 */
fun Context?.startActivityK(clazz: Class&lt;*&gt;) {
    this?.startActivity(Intent(this, clazz))
}

inline fun &lt;reified T&gt; Context?.startActivityK() {
    this?.startActivity(Intent(this, T::class.java))
}

/**
 * 不带回调,带参跳转
 */
fun Context?.startActivityK(intent: Intent) {
    this?.startActivity(intent)
}

fun Context?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(this, clazz)
        startActivity(intent.addPair(*pair))
    }
}

inline fun &lt;reified T&gt; Context?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(this, T::class.java)
        startActivity(intent.addPair(*pair))
    }
}

/**
 * 不带回调,无参跳转
 */
fun Fragment?.startActivityK(clazz: Class&lt;*&gt;) {
    this?.startActivity(Intent(activity, clazz))
}

inline fun &lt;reified T&gt; Fragment?.startActivityK() {
    this?.startActivity(Intent(activity, T::class.java))
}

/**
 * 不带回调,带参跳转
 */
fun Fragment?.startActivityK(intent: Intent) {
    this?.startActivity(intent)
}

fun Fragment?.startActivityK(clazz: Class&lt;*&gt;, vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(activity, clazz)
        startActivity(intent.addPair(*pair))
    }
}

inline fun &lt;reified T&gt; Fragment?.startActivityK(vararg pair: Pair&lt;String, Any?&gt;) {
    this?.run {
        val intent = Intent(activity, T::class.java)
        startActivity(intent.addPair(*pair))
    }
}


/**
 * Context扩展函数跳转
 */
fun Context?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult(clazz, callback)
}

fun Context?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult(intent, callback)
}

inline fun &lt;reified T&gt; Context?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this)?.startActivityForResult&lt;T&gt;(callback)

}

fun Context?.startActivityForResultK(
    clazz: Class&lt;*&gt;,
    vararg pair: Pair&lt;String, Any?&gt;,
    callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this)
        ?.startActivityForResult(clazz, callback, *pair)
}

inline fun &lt;reified T&gt; Context?.startActivityForResultK(
    vararg pair: Pair&lt;String, Any?&gt;,
    noinline callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this)
        ?.startActivityForResult&lt;T&gt;(callback, *pair)
}


/**
 * 上述方法在 fragment 中扩展
 */
fun Fragment?.startActivityForResultK(clazz: Class&lt;*&gt;, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult(clazz, callback)
}

fun Fragment?.startActivityForResultK(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult(intent, callback)
}

inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
    ActivityHelper.init(this?.context)?.startActivityForResult&lt;T&gt;(callback)
}

fun Fragment?.startActivityForResultK(
    clazz: Class&lt;*&gt;,
    vararg pair: Pair&lt;String, Any?&gt;,
    callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this?.context)
        ?.startActivityForResult(clazz, callback, *pair)
}

inline fun &lt;reified T&gt; Fragment?.startActivityForResultK(
    vararg pair: Pair&lt;String, Any?&gt;,
    noinline callback: ((Int, Intent?) -&gt; Unit)?
) {
    ActivityHelper.init(this?.context)
        ?.startActivityForResult&lt;T&gt;(callback, *pair)
}
</code></pre>
<ul>
<li>ActivityHelper</li>
</ul>
<pre><code class="language-kotlin">class ActivityHelper private constructor(activity: FragmentActivity) {
    private val TAG = &quot;MMMK&quot;
    var mContext: Activity? = null
    private var mRouterFragment: RouterFragment? = null

    init {
        mContext = activity
        mRouterFragment = getRouterFragment(activity)
    }

    companion object {
//        fun init(activity: FragmentActivity?): ActivityHelper? {
//            if (activity != null) return ActivityHelper(activity)
//            return null
//        }

        fun init(context: Context?): ActivityHelper? {
            if (context is FragmentActivity) return ActivityHelper(context)
            return null
        }
    }


    private fun getRouterFragment(activity: FragmentActivity): RouterFragment? {
        var routerFragment: RouterFragment? = findRouterFragment(activity)
        if (routerFragment == null) {
            //创建 fragment,加入当前 activity
            routerFragment = RouterFragment.newInstance()
            val sfm = activity.supportFragmentManager
            sfm.beginTransaction().add(routerFragment!!, TAG).commitAllowingStateLoss()
            sfm.executePendingTransactions()
        }
        return routerFragment
    }

    private fun findRouterFragment(activity: FragmentActivity): RouterFragment? {
        //通过 tag 获取 fragment
        return activity.supportFragmentManager.findFragmentByTag(TAG) as RouterFragment?
    }


    /**
     * 对Intent跳转,不带参数
     */
    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            startActivityForResult(intent, callback)
        }
    }

    inline fun &lt;reified T&gt; startActivityForResult(noinline callback: ((Int, Intent?) -&gt; Unit)?) {
        mContext?.run {
            val intent = Intent(mContext, T::class.java)
            startActivityForResult(intent, callback)
        }
    }

    /**
     *带参数跳转
     * @param T
     * @param pair
     * @param callback
     */
    inline fun &lt;reified T&gt; startActivityForResult(
        vararg pair: Pair&lt;String, Any?&gt;,
        noinline callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        if (mContext == null) return
        val intent = Intent(mContext, T::class.java)
        IntentKtx.addPair(intent, *pair)
        startActivityForResult(intent, callback)
    }

    inline fun &lt;reified T&gt; startActivityForResult(
        noinline callback: ((Int, Intent?) -&gt; Unit)?,
        vararg pair: Pair&lt;String, Any?&gt;
    ) {
        if (mContext == null) return
        val intent = Intent(mContext, T::class.java)
        IntentKtx.addPair(intent, *pair)
        startActivityForResult(intent, callback)
    }

    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        vararg pair: Pair&lt;String, Any?&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            IntentKtx.addPair(intent, *pair)
            startActivityForResult(intent, callback)
        }
    }

    fun startActivityForResult(
        clazz: Class&lt;*&gt;,
        callback: ((Int, Intent?) -&gt; Unit)?,
        vararg pair: Pair&lt;String, Any?&gt;
    ) {
        mContext?.run {
            val intent = Intent(this, clazz)
            IntentKtx.addPair(intent, *pair)
            startActivityForResult(intent, callback)
        }
    }

    /**
     * 对Intent跳转,带参数
     * @param intent  参数提取放入intent中
     * @param callback
     */
    fun startActivityForResult(intent: Intent, callback: ((Int, Intent?) -&gt; Unit)?) {
        mRouterFragment?.run {
            startActivityForResult(intent, callback)
        }
    }


}
</code></pre>
<h2 id="导入依赖">导入依赖</h2>
<p>不想复制更省事的方法，直接依赖即可。依赖如下：<br>
<a href="https://github.com/KiWiLss/LUtils">Github</a>上面有详细的文档。<br>
<a href="https://www.jitpack.io/v/KiWiLss/LUtils.svg">最新版</a></p>
<pre><code class="language-kotlin">    allprojects {
        repositories {
            ...
            maven { url 'https://www.jitpack.io' }
        }
    }

dependencies {
            implementation 'com.github.KiWiLss:LUtils:1.1.0'
    }

</code></pre>
<p>使用前要调用，获取到 Context：</p>
<pre><code>object LUtilsConfig{

    lateinit var mContext: Context
    fun init(context: Context) {
        mContext = context
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Activity Result Api DSl]]></title>
        <id>https://KiWiLss.github.io/activity-result-api-dsl/</id>
        <link href="https://KiWiLss.github.io/activity-result-api-dsl/">
        </link>
        <updated>2021-07-04T08:03:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在安卓开发中，跳转和申请权限设计的比较麻烦，网上有很多优秀的库解决这个问题，谷歌对这个问题做了处理，废弃了以前的方法。具体的使用方法可以参考末尾的参考博客。下面是对这些方法做的基本封装，方便使用。</p>
<h2 id="intentktx">IntentKtx</h2>
<p>这个类是对普通跳转的封装，可以用也可以不用，主要是方便实现简单的跳转。都是扩展函数，直接在 Activity/Fragment 中使用即可。</p>
<pre><code>createIntent            :生成Intent并添加参数(可选）
createIntentStart       :生成跳转的Intent并添加参数,也可以不添加参数
addPair                 :Intent 添加参数
startActivityK          :跳转

browse                  :打开浏览器
share                   :生调用分享，只能分享文本
email                   :发送邮件
makeCallPermission  :拨打电话，需要权限
makeCall                :拨打电话
sendSMS                 :发送短信
</code></pre>
<h2 id="封装使用界面跳转">封装使用界面跳转</h2>
<p>最新版可以参考官网 <a href="https://developer.android.google.cn/jetpack/androidx/releases/activity#kts">Activity</a>,<a href="https://developer.android.google.cn/jetpack/androidx/releases/fragment">Framgnet</a>。</p>
<h3 id="1导入依赖">1.导入依赖</h3>
<p>我试了一下只导入最后一个也可以，只是 activity对应的版本不是最新的，如果想两个都是最新的就像下面这样，导入两个就行了。下面是原生的依赖导入：</p>
<pre><code>   //activity
    def activity_version = &quot;1.2.3&quot;
    // Java language implementation
//    implementation &quot;androidx.activity:activity:$activity_version&quot;
    // Kotlin
    api &quot;androidx.activity:activity-ktx:$activity_version&quot;
    //fragment
    def fragment_version = &quot;1.3.4&quot;
    // Java language implementation
//    implementation &quot;androidx.fragment:fragment:$fragment_version&quot;
    // Kotlin
    api &quot;androidx.fragment:fragment-ktx:$fragment_version&quot;
</code></pre>
<p>封装后的依赖导入，最新版看最后的项目地址：</p>
<pre><code>maven { url 'https://www.jitpack.io' }
 
implementation 'com.gitee.quetzalcoatl:ActivityResultApi:0.0.3'
</code></pre>
<h3 id="2跳转使用">2.跳转使用</h3>
<ol>
<li>第一步生成 ActivityResultLauncher,在这里面可以监听回调。</li>
</ol>
<pre><code>  private val startTest = startActivityForResultK {
        //这里是回调,相当于 onActivityResult
        if (it.resultCode == RESULT_OK){
            //获取回传值,这里就是以前的 intent
            it.data?.run {
                Toast.makeText(this@MainActivity,
                    &quot;${getStringExtra(&quot;result&quot;)}&quot;, Toast.LENGTH_SHORT).show()
            }
        }
    }
</code></pre>
<ol start="2">
<li>第二步调用跳转</li>
</ol>
<pre><code> fun testStart(view: View) {
        //调用跳转
        startTest.launch(createIntentStart&lt;WelcomeActivity&gt;(&quot;text&quot; to &quot;这里可以传多个参数&quot;))
    }
</code></pre>
<ol start="3">
<li>获取参数，回传信息<br>
这里和以前用法一样，没有变化，示例如下：</li>
</ol>
<pre><code>  tvText.text = intent.getStringExtra(&quot;text&quot;)
    //回传任意值
        setResult(RESULT_OK,createIntent(&quot;result&quot; to &quot;hello&quot;))
        finish()
</code></pre>
<h2 id="申请权限">申请权限</h2>
<p>申请权限和上面使用步骤类似，这里做了两种封装，一个单纯的扩展函数，可以直接调用。另一个对扩展做了封装，可以更方便调用。具体用法看下面。</p>
<h3 id="申请单个权限">申请单个权限</h3>
<ol>
<li>和以前一样在清单文件申请权限，这里随便申请两个权限</li>
</ol>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
</code></pre>
<p>carme 和 write 就是这两个权限。</p>
<ol start="2">
<li>提前生成对象ActivityResultLauncher，两种用法看个人更喜欢哪种</li>
</ol>
<pre><code>//ktx 的用法
    val single = requestPermission(camera,
        granted = {
            //同意权限
        }, denied = {
            //拒绝权限
        }, explained = {
            //拒绝并且不再显示
        })
</code></pre>
<pre><code> // dsl 用法, 更好用更省事
    val singleDsl = requestPermissionK(camera) {
        //有两种写法,个人更喜欢下面这种不用写=,两个都写只有一个生效
        //granted = {}
        granted { /*同意权限*/ }
        denied { /*拒绝权限*/ }
        explained { /*拒绝并且不再显示*/ }
</code></pre>
<ol start="3">
<li>调用</li>
</ol>
<pre><code>//调用
//        single.launch(camera)
        singleDsl.launch(camera)
</code></pre>
<h3 id="申请多个权限">申请多个权限</h3>
<p>使用方法基本和上面类似，这次全部放在一起。</p>
<pre><code>  //ktx 写法
    val multiple = requestMultiplePermissions(
        allGranted = {
            //全部同意
        },denied = {
            //拒绝
        },explained = {
            //拒绝并不再显示
        }
    )
    //dsl
    val multipleDsl = requestPermissionK {
        allGranted {  }
        denied {  }
        explained {  }
    }
    fun applyMultiple(view: View) {
//        multiple.launch(arrayOf(camera,write))
        multipleDsl.launch(arrayOf(camera,write))
    }
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://gitee.com/quetzalcoatl/ActivityResultApi">项目地址</a></p>
<p><a href="https://juejin.cn/post/6844904200644591630">开源项目：使用 Activity Result API + Kotlin 扩展函数 封装权限请求库(支持 DSL 写法)</a></p>
<p><a href="https://www.jianshu.com/p/b18a57a497b3">Jetpack Activity Result API 优雅的实现页面传值</a></p>
<p><a href="https://mp.weixin.qq.com/s/r_9x7-48_tD-cFOX07GDfA">Android 新出功能 ActivityResultContract，真香！</a></p>
<p><a href="https://mp.weixin.qq.com/s/jcnFN73d002OfRXRx6u3yA">你好，Activity Results API！</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CharSequence 相关扩展收集]]></title>
        <id>https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/</id>
        <link href="https://KiWiLss.github.io/charsequence-xiang-guan-kuo-zhan-shou-ji/">
        </link>
        <updated>2021-07-04T07:47:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>主要是关于一些字符串判断相关内容，<strong>主要包括判断字符串是否含有空格、是否含有汉字、是否含有字母、是否含有数字、特殊符号</strong>等，字符串本身就有很多 Api 可以实现很多功能，但是对于判断方面就少了点，这里把收集到的常用的整理起来，可以直接使用。</p>
<h2 id="函数列表">函数列表</h2>
<ul>
<li>判断相关</li>
</ul>
<pre><code class="language-kotlin">isNotNullOrEmpty		:CharSequence不为 null 或者 empty
isHasSpecial			:是否含有特殊字符,true有，false没有
isHasChinese			:是否含有汉字,true有，false没有
isChinese				:是否全是汉字
isHasLower				:是否含有小写字母,true有，false没有
isLower					:是否全是大写字母
isHasCapital			:是否含有大写字母,true有，false没有
isCapital				:是否全是大写字母
isHasLetter				:是否含有字母，不区分大小写，true有，false没有
isLetter				:是否全是字母
isHasDigit				:是否含有数字，true有，false没有
isDigits				:是否全是数字，也可以用isDigitsOnly
isDigits2				:是否全是数字，也可以用isDigitsOnly
isHasSpace				:是否含有空格，true有，false没有
isSpace					:是否全是空格

Char.isSpace()			:判断字符是否是空格
</code></pre>
<ul>
<li>其他</li>
</ul>
<pre><code class="language-kotlin">
substringBetween		:指定裁剪出str中open和close包含着的那部分字符串
toFirstUpperCase		:首字母大写，或者调用capitalize
toFirstLowerCase		:首字母小写，或者调用decapitalize
substringUnDigits		:截取非数字，只能截取第一段连续的，不在首位截取不到
substringDigits			:截取数字，只能截取第一段连续的数字
substringAllDigits		:截取数字，截取所有的数字
stringSize				:特定字符串的数量
charSize				:含有特定字符的数量
spaceSize				:含有空格数量
</code></pre>
<h2 id="工具类">工具类</h2>
<pre><code class="language-kotlin">object CharSequenceKtx {
    //匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效
    const val SPACE = &quot;[\\s]&quot;

    //匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效
    const val UN_SPACE = &quot;[\\S]&quot;

    //数字字符匹配。等效于 [0-9]
    const val DIGITS = &quot;[\\d]&quot;

    //非数字字符匹配。等效于 [^0-9]
    const val UN_DIGITS = &quot;[\\D]&quot;

    //匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效
    const val DIGITS_LETTER_UNDERLINE = &quot;[\\w]&quot;

    //与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效
    const val UN_DIGITS_LETTER = &quot;[\\W]&quot;

    //匹配大写字母
    const val UPPERCASE_LETTER = &quot;[A-Z]&quot;

    //匹配小写字母
    const val LOWER_LETTER = &quot;[a-z]&quot;

    //匹配字母
    const val LETTER = &quot;[a-zA-Z]&quot;

    //匹配字母和数字
    const val DIGITS_LETTER = &quot;[a-zA-Z0-9]&quot;

    //匹配汉字
    const val CHINESE = &quot;[\u4e00-\u9fa5]&quot;

    //匹配特殊字符
    const val SPECIAL_CHARACTERS =
        &quot;[ _`~!@#$%^&amp;*()+=|{}':;',\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。，、？]|\n|\r|\t&quot;
}

//fun CharSequence?.isBank() = this.isBlank()


fun testSpace(): Unit {
    val test: String = &quot;hello&quot;
    val test2 = &quot;noSpace&quot;
    val test3 = &quot; 2321fdf汉字 --9**&amp;&quot;
    val test4 = &quot; he llo &quot;
    val test5 = &quot;函数 zifu 2134&quot;
    println(&quot;----------------&quot;)

    println(test4.removePrefix(&quot; &quot;))//移除前缀
    println(test4.removeSuffix(&quot; &quot;))//移除后缀
/*    println(test3.stringSize(&quot;2&quot;))
    println(test.stringSize(&quot;2&quot;))
    println(test.stringSize(&quot;l&quot;))*/

/*    println(test5.replace(Regex(&quot;[\\d]&quot;), &quot;*&quot;))//数字替换

    println(test5.replace(Regex(CharSequenceKtx.SPACE), &quot;&quot;))//删除所有空格
    println(test4.trim())
    println(test3.substringBefore(&quot;f&quot;))//截取指定字符串之前的内容*/


/*    println(test5.toUpperCase())//字母大写
    println(test.capitalize())//首字母大写
    println(test2.decapitalize())//首字母小写
    println(test2.toLowerCase())//字母小写*/

//    println(test5.contains(Regex(CharSequenceKtx.DIGITS)))
//    println(test5.contains(Regex(CharSequenceKtx.UPPERCASE_LETTER)))
/*    println(test.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母
    println(test2.matches(Regex(&quot;[a-z]*&quot;)))//是否全是小写字母

    println(test.contains(Regex(CharSequenceKtx.LOWER_LETTER)))
    println(test.matches(Regex(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;)))
    println(&quot;${CharSequenceKtx.LOWER_LETTER}*&quot;)
    println(test5.contains(Regex(CharSequenceKtx.CHINESE)))
    println(test5.matches(Regex(CharSequenceKtx.CHINESE + &quot;*&quot;)))*/
//    println(test2.first().toUpperCase() + test2.substring(1))
    //过滤非数字
    /*  println(test3.filter {
          it.isDigit()
      })*/
    /*  println(test3.substringUnDigits())
      println(test2.substringUnDigits())*/
//    println(test.substringDigits())
//    println(test5.substringDigits())

}

/**
 *CharSequence不为 null 或者 empty
 */
fun CharSequence?.isNotNullOrEmpty() = !isNullOrEmpty()

/**
 *〈指定裁剪出str中open和close包含着的那部分字符串〉
 * @param open
 * @param close
 * @return
 */
fun CharSequence?.substringBetween(open: String?, close: String?): String? {
    if (isNullOrEmpty() || open.isNullOrEmpty() || close.isNullOrEmpty()) return null
    val start = this!!.indexOf(open)
    if (start != -1) {
        val end = indexOf(close, start + open.length)
        if (end != -1) {
            return substring(start + open.length, end)
        }
    }
    return null
}

fun CharSequence?.substringBetween(tag: String?) = substringBetween(tag, tag)

/**
 *首字母大写，或者调用capitalize
 * @return
 */
fun CharSequence.toFirstUpperCase(): CharSequence {
    if (isEmpty()) {
        return &quot;&quot;
    }
    return first().toUpperCase() + substring(1)
}

/**
 *首字母小写，或者调用decapitalize
 * @return
 */
fun CharSequence.toFirstLowerCase(): CharSequence {
    if (isEmpty()) {
        return &quot;&quot;
    }
    return first().toLowerCase() + substring(1)
}

/**
 *截取非数字，只能截取第一段连续的，不在首位截取不到
 * @return
 */
fun CharSequence.substringUnDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\D+&quot;)
    val matcher = pattern.matcher(this)
    while (matcher.find()) {
        return matcher.group(0)
    }
    return &quot;&quot;
}

/**
 *截取数字，只能截取第一段连续的数字
 * @return
 */
fun CharSequence.substringDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\d+&quot;)
    val matcher = pattern.matcher(this)
    while (matcher.find()) {
        return matcher.group(0)
    }
    return &quot;&quot;
}

/**
 *截取数字，截取所有的数字
 * @return
 */
fun CharSequence.substringAllDigits(): CharSequence {
    val pattern = Pattern.compile(&quot;\\d+&quot;)
    val matcher = pattern.matcher(this)
    val sb = StringBuilder()
    while (matcher.find()) {
        sb.append(matcher.group())
    }
    return sb
}

/**
 *特定字符串的数量
 * @param tag
 * @return
 */
fun CharSequence.stringSize(tag: String): Int {
    return split(tag).size - 1
}

/**
 *含有特定字符的数量
 * @param char
 * @return
 */
fun CharSequence.charSize(char: Char): Int {
    var count = 0
    forEach {
        if (it == char) {
            count++
        }
    }
    return count
}

/**
 *含有空格数量
 * @return
 */
fun CharSequence.spaceSize(): Int {
    var count = 0
    forEach {
        if (it.isSpace()) {
            count++
        }
    }
    return count
}

/**
 *是否含有特殊字符,true有，false没有
 */
fun CharSequence.isHasSpecial() = contains(Regex(CharSequenceKtx.SPECIAL_CHARACTERS))

/**
 *是否含有汉字,true有，false没有
 */
fun CharSequence.isHasChinese() = contains(Regex(CharSequenceKtx.CHINESE))

/**
 *是否全是汉字
 */
fun CharSequence.isChinese() = matches(Regex(CharSequenceKtx.CHINESE + &quot;+&quot;))

/**
 *是否含有小写字母,true有，false没有
 */
fun CharSequence.isHasLower() = contains(Regex(CharSequenceKtx.LOWER_LETTER))

/**
 *是否全是大写字母
 */
fun CharSequence.isLower() = matches(Regex(CharSequenceKtx.LOWER_LETTER + &quot;+&quot;))

/**
 *是否含有大写字母,true有，false没有
 */
fun CharSequence.isHasCapital() = contains(Regex(CharSequenceKtx.UPPERCASE_LETTER))

/**
 *是否全是大写字母
 */
fun CharSequence.isCapital() = matches(Regex(CharSequenceKtx.UPPERCASE_LETTER + &quot;+&quot;))

/**
 *是否含有字母，不区分大小写，true有，false没有
 */
fun CharSequence.isHasLetter() = contains(Regex(CharSequenceKtx.LETTER))

/**
 *是否全是字母
 */
fun CharSequence.isLetter() = matches(Regex(CharSequenceKtx.LETTER + &quot;+&quot;))

/**
 *是否含有数字，true有，false没有
 */
fun CharSequence.isHasDigit() = contains(Regex(CharSequenceKtx.DIGITS))

/**
 *是否全是数字，也可以用isDigitsOnly
 */
fun CharSequence.isDigits() = matches(Regex(CharSequenceKtx.DIGITS + &quot;+&quot;))

/**
 *是否全都是数字
 */
fun CharSequence.isDigits2() = Pattern.compile(&quot;[\\d]+&quot;).matcher(this).matches()

/**
 *是否含有空格，true有，false没有
 */
fun CharSequence.isHasSpace() = contains(Regex(CharSequenceKtx.SPACE))

/**
 *是否全是空格
 */
fun CharSequence.isSpace() = matches(Regex(CharSequenceKtx.SPACE + &quot;+&quot;))

/**
 *判断字符是否是空格
 */
fun Char.isSpace() = this.toString().isHasSpace()
</code></pre>
<p>持续整理中...</p>
]]></content>
    </entry>
</feed>